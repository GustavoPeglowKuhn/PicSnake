CCS PCH C Compiler, Version 5.015, 5967               29-dez-15 13:47

               Filename:   D:\pasta\14\Grafic LCD\snake glcd\main.lst

               ROM used:   2410 bytes (7%)
                           Largest free fragment is 30358
               RAM used:   274 (13%) at main() level
                           303 (15%) worst case
               Stack used: 4 locations
               Stack size: 31

*
0000:  GOTO   0864
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
0004:  CLRF   FF7
0006:  ADDLW  14
0008:  MOVWF  FF6
000A:  MOVLW  00
000C:  ADDWFC FF7,F
000E:  TBLRD*+
0010:  MOVF   FF5,W
0012:  RETURN 0
0014:  DATA 00,00
0016:  DATA 00,00
0018:  DATA 00,00
001A:  DATA 00,5F
001C:  DATA 00,00
001E:  DATA 00,03
0020:  DATA 00,03
0022:  DATA 00,14
0024:  DATA 3E,14
0026:  DATA 3E,14
0028:  DATA 24,2A
002A:  DATA 7F,2A
002C:  DATA 12,43
002E:  DATA 33,08
0030:  DATA 66,61
0032:  DATA 36,49
0034:  DATA 55,22
0036:  DATA 50,00
0038:  DATA 05,03
003A:  DATA 00,00
003C:  DATA 00,1C
003E:  DATA 22,41
0040:  DATA 00,00
0042:  DATA 41,22
0044:  DATA 1C,00
0046:  DATA 14,08
0048:  DATA 3E,08
004A:  DATA 14,08
004C:  DATA 08,3E
004E:  DATA 08,08
0050:  DATA 00,50
0052:  DATA 30,00
0054:  DATA 00,08
0056:  DATA 08,08
0058:  DATA 08,08
005A:  DATA 00,60
005C:  DATA 60,00
005E:  DATA 00,20
0060:  DATA 10,08
0062:  DATA 04,02
0064:  DATA 3E,51
0066:  DATA 49,45
0068:  DATA 3E,04
006A:  DATA 02,7F
006C:  DATA 00,00
006E:  DATA 42,61
0070:  DATA 51,49
0072:  DATA 46,22
0074:  DATA 41,49
0076:  DATA 49,36
0078:  DATA 18,14
007A:  DATA 12,7F
007C:  DATA 10,27
007E:  DATA 45,45
0080:  DATA 45,39
0082:  DATA 3E,49
0084:  DATA 49,49
0086:  DATA 32,01
0088:  DATA 01,71
008A:  DATA 09,07
008C:  DATA 36,49
008E:  DATA 49,49
0090:  DATA 36,26
0092:  DATA 49,49
0094:  DATA 49,3E
0096:  DATA 00,36
0098:  DATA 36,00
009A:  DATA 00,00
009C:  DATA 56,36
009E:  DATA 00,00
00A0:  DATA 08,14
00A2:  DATA 22,41
00A4:  DATA 00,14
00A6:  DATA 14,14
00A8:  DATA 14,14
00AA:  DATA 00,41
00AC:  DATA 22,14
00AE:  DATA 08,02
00B0:  DATA 01,51
00B2:  DATA 09,06
00B4:  DATA 3E,41
00B6:  DATA 59,55
00B8:  DATA 5E,7E
00BA:  DATA 09,09
00BC:  DATA 09,7E
00BE:  DATA 7F,49
00C0:  DATA 49,49
00C2:  DATA 36,3E
00C4:  DATA 41,41
00C6:  DATA 41,22
00C8:  DATA 7F,41
00CA:  DATA 41,41
00CC:  DATA 3E,7F
00CE:  DATA 49,49
00D0:  DATA 49,41
00D2:  DATA 7F,09
00D4:  DATA 09,09
00D6:  DATA 01,3E
00D8:  DATA 41,41
00DA:  DATA 49,3A
00DC:  DATA 7F,08
00DE:  DATA 08,08
00E0:  DATA 7F,00
00E2:  DATA 41,7F
00E4:  DATA 41,00
00E6:  DATA 30,40
00E8:  DATA 40,40
00EA:  DATA 3F,7F
00EC:  DATA 08,14
00EE:  DATA 22,41
00F0:  DATA 7F,40
00F2:  DATA 40,40
00F4:  DATA 40,7F
00F6:  DATA 02,0C
00F8:  DATA 02,7F
00FA:  DATA 7F,02
00FC:  DATA 04,08
00FE:  DATA 7F,3E
0100:  DATA 41,41
0102:  DATA 41,3E
0104:  DATA 7F,09
0106:  DATA 09,09
0108:  DATA 06,1E
010A:  DATA 21,21
010C:  DATA 21,5E
010E:  DATA 7F,09
0110:  DATA 09,09
0112:  DATA 76,00
0114:  CLRF   FF7
0116:  ADDLW  24
0118:  MOVWF  FF6
011A:  MOVLW  01
011C:  ADDWFC FF7,F
011E:  TBLRD*+
0120:  MOVF   FF5,W
0122:  RETURN 0
0124:  DATA 26,49
0126:  DATA 49,49
0128:  DATA 32,01
012A:  DATA 01,7F
012C:  DATA 01,01
012E:  DATA 3F,40
0130:  DATA 40,40
0132:  DATA 3F,1F
0134:  DATA 20,40
0136:  DATA 20,1F
0138:  DATA 7F,20
013A:  DATA 10,20
013C:  DATA 7F,41
013E:  DATA 22,1C
0140:  DATA 22,41
0142:  DATA 07,08
0144:  DATA 70,08
0146:  DATA 07,61
0148:  DATA 51,49
014A:  DATA 45,43
014C:  DATA 00,7F
014E:  DATA 41,00
0150:  DATA 00,02
0152:  DATA 04,08
0154:  DATA 10,20
0156:  DATA 00,00
0158:  DATA 41,7F
015A:  DATA 00,04
015C:  DATA 02,01
015E:  DATA 02,04
0160:  DATA 40,40
0162:  DATA 40,40
0164:  DATA 40,00
0166:  DATA 01,02
0168:  DATA 04,00
016A:  DATA 20,54
016C:  DATA 54,54
016E:  DATA 78,7F
0170:  DATA 44,44
0172:  DATA 44,38
0174:  DATA 38,44
0176:  DATA 44,44
0178:  DATA 44,38
017A:  DATA 44,44
017C:  DATA 44,7F
017E:  DATA 38,54
0180:  DATA 54,54
0182:  DATA 18,04
0184:  DATA 04,7E
0186:  DATA 05,05
0188:  DATA 08,54
018A:  DATA 54,54
018C:  DATA 3C,7F
018E:  DATA 08,04
0190:  DATA 04,78
0192:  DATA 00,44
0194:  DATA 7D,40
0196:  DATA 00,20
0198:  DATA 40,44
019A:  DATA 3D,00
019C:  DATA 7F,10
019E:  DATA 28,44
01A0:  DATA 00,00
01A2:  DATA 41,7F
01A4:  DATA 40,00
01A6:  DATA 7C,04
01A8:  DATA 78,04
01AA:  DATA 78,7C
01AC:  DATA 08,04
01AE:  DATA 04,78
01B0:  DATA 38,44
01B2:  DATA 44,44
01B4:  DATA 38,7C
01B6:  DATA 14,14
01B8:  DATA 14,08
01BA:  DATA 08,14
01BC:  DATA 14,14
01BE:  DATA 7C,00
01C0:  DATA 7C,08
01C2:  DATA 04,04
01C4:  DATA 48,54
01C6:  DATA 54,54
01C8:  DATA 20,04
01CA:  DATA 04,3F
01CC:  DATA 44,44
01CE:  DATA 3C,40
01D0:  DATA 40,20
01D2:  DATA 7C,1C
01D4:  DATA 20,40
01D6:  DATA 20,1C
01D8:  DATA 3C,40
01DA:  DATA 30,40
01DC:  DATA 3C,44
01DE:  DATA 28,10
01E0:  DATA 28,44
01E2:  DATA 0C,50
01E4:  DATA 50,50
01E6:  DATA 3C,44
01E8:  DATA 64,54
01EA:  DATA 4C,44
01EC:  DATA 00,08
01EE:  DATA 36,41
01F0:  DATA 41,00
01F2:  DATA 00,7F
01F4:  DATA 00,00
01F6:  DATA 41,41
01F8:  DATA 36,08
01FA:  DATA 00,02
01FC:  DATA 01,02
01FE:  DATA 04,02
*
07C8:  ADDWF  FE8,W
07CA:  CLRF   FF7
07CC:  RLCF   FF7,F
07CE:  ADDLW  E3
07D0:  MOVWF  FF6
07D2:  MOVLW  07
07D4:  ADDWFC FF7,F
07D6:  TBLRD*-
07D8:  MOVF   FF5,W
07DA:  MOVWF  FFA
07DC:  TBLRD*
07DE:  MOVF   FF5,W
07E0:  MOVWF  FF9
07E2:  DATA 46,06
07E4:  DATA 56,06
07E6:  DATA 66,06
07E8:  DATA 76,06
....................  
.................... #list 
....................  
.................... #device ADC=8 
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(clock=4MHz,crystal=4MHz) 
*
0604:  MOVLW  01
0606:  MOVWF  FEA
0608:  MOVLW  16
060A:  MOVWF  FE9
060C:  MOVF   FEF,W
060E:  BZ    062C
0610:  MOVLW  01
0612:  MOVWF  01
0614:  CLRF   00
0616:  DECFSZ 00,F
0618:  BRA    0616
061A:  DECFSZ 01,F
061C:  BRA    0614
061E:  MOVLW  4A
0620:  MOVWF  00
0622:  DECFSZ 00,F
0624:  BRA    0622
0626:  BRA    0628
0628:  DECFSZ FEF,F
062A:  BRA    0610
062C:  RETURN 0
....................  
.................... //bibliotecas 
.................... #include <GLCD.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           GLCD.C                                //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// an LED backlight. The HDM64GS12 is 128 pixles across and 64     //// 
.................... //// pixels down. The driver treats the upper left pixel as (0,0).   //// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0 - LCD operating voltage is connected from a 20k Ohm POT//// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C0                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    //// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1,y1,x2,y2,color)                                   //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color.                                     //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1,y1,x2,y2,fill,color)                              //// 
.................... ////     * Draws a rectangle with upper left point (x1,y1) and lower //// 
.................... ////       right point (x2,y2).                                      //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1,y1,x2,y2,width,color)                              //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point.                                             //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x,y,radius,fill,color)                             //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x,y,textptr,size,color)                            //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y).//// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall.           //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - The given text is character wrapped. If this       //// 
.................... ////       function is used on a different size display, then change //// 
.................... ////       the GLCD_WIDTH define appropriately.                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef GLCD_C 
.................... #define GLCD_C 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH 128    // Used for text wrapping by glcd_text57 function 
.................... #endif 
....................  
.................... #define ON  1 
.................... #define OFF 0 
....................  
.................... #define YES 1 
.................... #define NO  0 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1 PIN_B0   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2 PIN_B1   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI  PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW  PIN_B4   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E   PIN_B5   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST PIN_C0   // Reset 
.................... #endif 
....................  
....................  
....................  
.................... BYTE glcd_readByte(BYTE chip); 
.................... void glcd_writeByte(BYTE chip, BYTE data); 
.................... void glcd_fillScreen(int1 color); 
....................  
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
....................  
.................... // Purpose:       Initialize a graphic LCD. This must be called before any 
.................... //                other glcd function is used. 
.................... // Inputs:        The initialization mode 
.................... //                OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... // Date:          5/28/2003 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
02C8:  BCF    F94.0
02CA:  BSF    F8B.0
....................    output_low(GLCD_E); 
02CC:  BCF    F93.5
02CE:  BCF    F8A.5
....................    output_low(GLCD_CS1); 
02D0:  BCF    F93.0
02D2:  BCF    F8A.0
....................    output_low(GLCD_CS2); 
02D4:  BCF    F93.1
02D6:  BCF    F8A.1
....................  
....................    output_low(GLCD_DI);                // Set for instruction 
02D8:  BCF    F93.2
02DA:  BCF    F8A.2
....................    glcd_writeByte(GLCD_CS1, 0xC0);     // Specify first RAM line at the top 
02DC:  MOVLW  08
02DE:  MOVLB  1
02E0:  MOVWF  x2D
02E2:  MOVLW  C0
02E4:  MOVWF  x2E
02E6:  MOVLB  0
02E8:  RCALL  0200
....................    glcd_writeByte(GLCD_CS2, 0xC0);     //   of the screen 
02EA:  MOVLW  09
02EC:  MOVLB  1
02EE:  MOVWF  x2D
02F0:  MOVLW  C0
02F2:  MOVWF  x2E
02F4:  MOVLB  0
02F6:  RCALL  0200
....................    glcd_writeByte(GLCD_CS1, 0x40);     // Set the column address to 0 
02F8:  MOVLW  08
02FA:  MOVLB  1
02FC:  MOVWF  x2D
02FE:  MOVLW  40
0300:  MOVWF  x2E
0302:  MOVLB  0
0304:  RCALL  0200
....................    glcd_writeByte(GLCD_CS2, 0x40); 
0306:  MOVLW  09
0308:  MOVLB  1
030A:  MOVWF  x2D
030C:  MOVLW  40
030E:  MOVWF  x2E
0310:  MOVLB  0
0312:  RCALL  0200
....................    glcd_writeByte(GLCD_CS1, 0xB8);     // Set the page address to 0 
0314:  MOVLW  08
0316:  MOVLB  1
0318:  MOVWF  x2D
031A:  MOVLW  B8
031C:  MOVWF  x2E
031E:  MOVLB  0
0320:  RCALL  0200
....................    glcd_writeByte(GLCD_CS2, 0xB8); 
0322:  MOVLW  09
0324:  MOVLB  1
0326:  MOVWF  x2D
0328:  MOVLW  B8
032A:  MOVWF  x2E
032C:  MOVLB  0
032E:  RCALL  0200
....................    if(mode == ON) 
0330:  MOVLB  1
0332:  DECFSZ x12,W
0334:  BRA    0354
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3F);  // Turn the display on 
0336:  MOVLW  08
0338:  MOVWF  x2D
033A:  MOVLW  3F
033C:  MOVWF  x2E
033E:  MOVLB  0
0340:  RCALL  0200
....................       glcd_writeByte(GLCD_CS2, 0x3F); 
0342:  MOVLW  09
0344:  MOVLB  1
0346:  MOVWF  x2D
0348:  MOVLW  3F
034A:  MOVWF  x2E
034C:  MOVLB  0
034E:  RCALL  0200
....................    } 
0350:  BRA    036E
0352:  MOVLB  1
....................    else 
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3E);  // Turn the display off 
0354:  MOVLW  08
0356:  MOVWF  x2D
0358:  MOVLW  3E
035A:  MOVWF  x2E
035C:  MOVLB  0
035E:  RCALL  0200
....................       glcd_writeByte(GLCD_CS2, 0x3E); 
0360:  MOVLW  09
0362:  MOVLB  1
0364:  MOVWF  x2D
0366:  MOVLW  3E
0368:  MOVWF  x2E
036A:  MOVLB  0
036C:  RCALL  0200
....................    } 
....................  
....................    glcd_fillScreen(OFF);               // Clear the display 
036E:  MOVLB  1
0370:  CLRF   x13
0372:  MOVLB  0
0374:  RCALL  0232
0376:  GOTO   08E0 (RETURN)
.................... } 
....................  
....................  
.................... // Purpose:       Turn a pixel on a graphic LCD on or off 
.................... // Inputs:        x - the x coordinate of the pixel 
.................... //                y - the y coordinate of the pixel 
.................... //                color - ON or OFF 
.................... // Output:        1 if coordinate out of range, 0 if in range 
.................... void glcd_pixel(int x, int y, int1 color) 
*
03C0:  MOVLW  08
03C2:  MOVLB  1
03C4:  MOVWF  x2B
.................... { 
....................    BYTE data; 
....................    BYTE chip = GLCD_CS1;  // Stores which chip to use on the LCD 
....................  
....................    if(x > 63)  // Check for first or second display area 
03C6:  MOVF   x27,W
03C8:  SUBLW  3F
03CA:  BC    03D4
....................    { 
....................       x -= 64; 
03CC:  MOVLW  40
03CE:  SUBWF  x27,F
....................       chip = GLCD_CS2; 
03D0:  MOVLW  09
03D2:  MOVWF  x2B
....................    } 
....................  
....................    output_low(GLCD_DI);                                     // Set for instruction 
03D4:  BCF    F93.2
03D6:  BCF    F8A.2
....................    bit_clear(x,7);                                          // Clear the MSB. Part of an instruction code 
03D8:  BCF    x27.7
....................    bit_set(x,6);                                            // Set bit 6. Also part of an instruction code 
03DA:  BSF    x27.6
....................    glcd_writeByte(chip, x);                                 // Set the horizontal address 
03DC:  MOVFF  12B,12D
03E0:  MOVFF  127,12E
03E4:  MOVLB  0
03E6:  RCALL  0200
....................    glcd_writeByte(chip, (y/8 & 0b10111111) | 0b10111000);   // Set the vertical page address 
03E8:  MOVLB  1
03EA:  RRCF   x28,W
03EC:  MOVWF  00
03EE:  RRCF   00,F
03F0:  RRCF   00,F
03F2:  MOVLW  1F
03F4:  ANDWF  00,F
03F6:  MOVF   00,W
03F8:  ANDLW  BF
03FA:  IORLW  B8
03FC:  MOVWF  x2C
03FE:  MOVFF  12B,12D
0402:  MOVWF  x2E
0404:  MOVLB  0
0406:  RCALL  0200
....................    output_high(GLCD_DI);                                    // Set for data 
0408:  BCF    F93.2
040A:  BSF    F8A.2
....................    data = glcd_readByte(chip); 
040C:  MOVFF  12B,12C
0410:  BRA    037A
0412:  MOVFF  01,12A
....................  
....................    if(color == ON) 
0416:  MOVLB  1
0418:  DECFSZ x29,W
041A:  BRA    043A
....................       bit_set(data, y%8);        // Turn the pixel on 
041C:  MOVF   x28,W
041E:  ANDLW  07
0420:  MOVWF  x2C
0422:  MOVLW  01
0424:  MOVWF  00
0426:  MOVF   x2C,W
0428:  MOVWF  01
042A:  BZ    0434
042C:  BCF    FD8.0
042E:  RLCF   00,F
0430:  DECFSZ 01,F
0432:  BRA    042C
0434:  MOVF   00,W
0436:  IORWF  x2A,F
0438:  BRA    0458
....................    else                          // or 
....................       bit_clear(data, y%8);      // turn the pixel off 
043A:  MOVF   x28,W
043C:  ANDLW  07
043E:  MOVWF  x2C
0440:  MOVLW  01
0442:  MOVWF  00
0444:  MOVF   x2C,W
0446:  MOVWF  01
0448:  BZ    0452
044A:  BCF    FD8.0
044C:  RLCF   00,F
044E:  DECFSZ 01,F
0450:  BRA    044A
0452:  MOVF   00,W
0454:  XORLW  FF
0456:  ANDWF  x2A,F
....................    output_low(GLCD_DI);          // Set for instruction 
0458:  BCF    F93.2
045A:  BCF    F8A.2
....................    glcd_writeByte(chip, x);      // Set the horizontal address 
045C:  MOVFF  12B,12D
0460:  MOVFF  127,12E
0464:  MOVLB  0
0466:  RCALL  0200
....................    output_high(GLCD_DI);         // Set for data 
0468:  BCF    F93.2
046A:  BSF    F8A.2
....................    glcd_writeByte(chip, data);   // Write the pixel data 
046C:  MOVFF  12B,12D
0470:  MOVFF  12A,12E
0474:  RCALL  0200
0476:  RETURN 0
.................... } 
....................  
....................  
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... void glcd_line(int x1, int y1, int x2, int y2, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, dx, dy; 
....................    signed long P; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
....................    x = x1; 
....................    y = y1; 
....................  
....................    if(x1 > x2) 
....................       addx = -1; 
....................    else 
....................       addx = 1; 
....................    if(y1 > y2) 
....................       addy = -1; 
....................    else 
....................       addy = 1; 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          glcd_pixel(x, y, color); 
....................  
....................          if(P < 0) 
....................          { 
....................             P += 2*dy; 
....................             x += addx; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          glcd_pixel(x, y, color); 
....................  
....................          if(P < 0) 
....................          { 
....................             P += 2*dx; 
....................             y += addy; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... void glcd_rect(int x1, int y1, int x2, int y2, int fill, int1 color) 
.................... { 
....................    if(fill) 
....................    { 
....................       int y, ymax;                          // Find the y min and max 
....................       if(y1 < y2) 
....................       { 
....................          y = y1; 
....................          ymax = y2; 
....................       } 
....................       else 
....................       { 
....................          y = y2; 
....................          ymax = y1; 
....................       } 
....................  
....................       for(; y<=ymax; ++y)                    // Draw lines to fill the rectangle 
....................          glcd_line(x1, y, x2, y, color); 
....................    } 
....................    else 
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
....................       glcd_line(x1, y2, x2, y2, color); 
....................       glcd_line(x1, y1, x1, y2, color); 
....................       glcd_line(x2, y1, x2, y2, color); 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... void glcd_bar(int x1, int y1, int x2, int y2, int width, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, j; 
....................    signed long P, dx, dy, c1, c2; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
....................    x = x1; 
....................    y = y1; 
....................    c1 = -dx*x1 - dy*y1; 
....................    c2 = -dx*x2 - dy*y2; 
....................  
....................    if(x1 > x2) 
....................    { 
....................       addx = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addx = 1; 
....................    if(y1 > y2) 
....................    { 
....................       addy = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addy = 1; 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x, y+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P += 2*dy; 
....................             x += addx; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P += 2*dx; 
....................             y += addy; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x+j, y, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... void glcd_circle(int x, int y, int radius, int1 fill, int1 color) 
.................... { 
....................    signed int a, b, P; 
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................  
....................    do 
....................    { 
....................       if(fill) 
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else 
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
....................          glcd_pixel(b+x, a+y, color); 
....................          glcd_pixel(x-a, b+y, color); 
....................          glcd_pixel(x-b, a+y, color); 
....................          glcd_pixel(b+x, y-a, color); 
....................          glcd_pixel(a+x, y-b, color); 
....................          glcd_pixel(x-a, y-b, color); 
....................          glcd_pixel(x-b, y-a, color); 
....................       } 
....................  
....................       if(P < 0) 
....................          P+= 3 + 2*a++; 
....................       else 
....................          P+= 5 + 2*(a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... void glcd_text57(int x, int y, char* textptr, int size, int1 color) 
.................... { 
....................    int i, j, k, l, m;                     // Loop counters 
....................    BYTE pixelData[5];                     // Stores character data 
....................  
....................    for(i=0; textptr[i] != '\0'; ++i, ++x) // Loop through the passed string 
0478:  MOVLB  1
047A:  CLRF   x1B
047C:  CLRF   03
047E:  MOVF   x1B,W
0480:  ADDWF  x17,W
0482:  MOVWF  FE9
0484:  MOVF   x18,W
0486:  ADDWFC 03,W
0488:  MOVWF  FEA
048A:  MOVF   FEF,F
048C:  BTFSC  FD8.2
048E:  BRA    05FE
....................    { 
....................       if(textptr[i] < 'S') // Checks if the letter is in the first text array 
0490:  CLRF   03
0492:  MOVF   x1B,W
0494:  ADDWF  x17,W
0496:  MOVWF  FE9
0498:  MOVF   x18,W
049A:  ADDWFC 03,W
049C:  MOVWF  FEA
049E:  MOVF   FEF,W
04A0:  SUBLW  52
04A2:  BNC   04F2
....................          memcpy(pixelData, TEXT[textptr[i]-' '], 5); 
04A4:  CLRF   03
04A6:  MOVF   x1B,W
04A8:  ADDWF  x17,W
04AA:  MOVWF  FE9
04AC:  MOVF   x18,W
04AE:  ADDWFC 03,W
04B0:  MOVWF  FEA
04B2:  MOVLW  20
04B4:  SUBWF  FEF,W
04B6:  MULLW  05
04B8:  MOVF   FF3,W
04BA:  CLRF   03
04BC:  MOVWF  x25
04BE:  MOVLW  01
04C0:  MOVWF  FEA
04C2:  MOVLW  20
04C4:  MOVWF  FE9
04C6:  CLRF   x29
04C8:  MOVFF  125,128
04CC:  MOVFF  FF2,126
04D0:  BCF    FF2.7
04D2:  MOVLW  05
04D4:  MOVWF  01
04D6:  CLRF   FF7
04D8:  MOVF   x25,W
04DA:  MOVLB  0
04DC:  RCALL  0004
04DE:  TBLRD*-
04E0:  TBLRD*+
04E2:  MOVFF  FF5,FEE
04E6:  DECFSZ 01,F
04E8:  BRA    04E0
04EA:  MOVLB  1
04EC:  BTFSC  x26.7
04EE:  BSF    FF2.7
04F0:  BRA    055E
....................       else if(textptr[i] <= '~') // Check if the letter is in the second array 
04F2:  CLRF   03
04F4:  MOVF   x1B,W
04F6:  ADDWF  x17,W
04F8:  MOVWF  FE9
04FA:  MOVF   x18,W
04FC:  ADDWFC 03,W
04FE:  MOVWF  FEA
0500:  MOVF   FEF,W
0502:  SUBLW  7E
0504:  BNC   0554
....................          memcpy(pixelData, TEXT2[textptr[i]-'S'], 5); 
0506:  CLRF   03
0508:  MOVF   x1B,W
050A:  ADDWF  x17,W
050C:  MOVWF  FE9
050E:  MOVF   x18,W
0510:  ADDWFC 03,W
0512:  MOVWF  FEA
0514:  MOVLW  53
0516:  SUBWF  FEF,W
0518:  MULLW  05
051A:  MOVF   FF3,W
051C:  CLRF   03
051E:  MOVWF  x25
0520:  MOVLW  01
0522:  MOVWF  FEA
0524:  MOVLW  20
0526:  MOVWF  FE9
0528:  CLRF   x29
052A:  MOVFF  125,128
052E:  MOVFF  FF2,126
0532:  BCF    FF2.7
0534:  MOVLW  05
0536:  MOVWF  01
0538:  CLRF   FF7
053A:  MOVF   x25,W
053C:  MOVLB  0
053E:  RCALL  0114
0540:  TBLRD*-
0542:  TBLRD*+
0544:  MOVFF  FF5,FEE
0548:  DECFSZ 01,F
054A:  BRA    0542
054C:  MOVLB  1
054E:  BTFSC  x26.7
0550:  BSF    FF2.7
0552:  BRA    055E
....................       else 
....................          memcpy(pixelData, TEXT[0], 5);   // Default to space 
0554:  CLRF   x20
0556:  CLRF   x21
0558:  CLRF   x22
055A:  CLRF   x23
055C:  CLRF   x24
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
055E:  MOVF   x19,W
0560:  MULLW  05
0562:  MOVF   FF3,W
0564:  ADDWF  x15,W
0566:  SUBLW  7F
0568:  BC    0576
....................       { 
....................          x = 0;                           // Set x at far left position 
056A:  CLRF   x15
....................          y += 7*size + 1;                 // Set y at next position down 
056C:  MOVF   x19,W
056E:  MULLW  07
0570:  MOVF   FF3,W
0572:  ADDLW  01
0574:  ADDWF  x16,F
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
0576:  CLRF   x1C
0578:  MOVF   x1C,W
057A:  SUBLW  04
057C:  BNC   05F8
....................       { 
....................          for(k=0; k<7*size; ++k)          // Loop through the vertical pixels 
057E:  CLRF   x1D
0580:  MOVF   x19,W
0582:  MULLW  07
0584:  MOVF   FF3,W
0586:  SUBWF  x1D,W
0588:  BC    05F0
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
058A:  CLRF   03
058C:  MOVF   x1C,W
058E:  ADDLW  20
0590:  MOVWF  FE9
0592:  MOVLW  01
0594:  ADDWFC 03,W
0596:  MOVWF  FEA
0598:  MOVFF  FEF,125
059C:  MOVFF  125,00
05A0:  MOVF   x1D,W
05A2:  MOVWF  01
05A4:  BZ    05AE
05A6:  BCF    FD8.0
05A8:  RRCF   00,F
05AA:  DECFSZ 01,F
05AC:  BRA    05A6
05AE:  BTFSS  00.0
05B0:  BRA    05EC
....................             { 
....................                for(l=0; l<size; ++l)      // The next two loops change the 
05B2:  CLRF   x1E
05B4:  MOVF   x19,W
05B6:  SUBWF  x1E,W
05B8:  BC    05EC
....................                {                          // character's size 
....................                   for(m=0; m<size; ++m) 
05BA:  CLRF   x1F
05BC:  MOVF   x19,W
05BE:  SUBWF  x1F,W
05C0:  BC    05E8
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
05C2:  MOVF   x1F,W
05C4:  ADDWF  x15,W
05C6:  MOVWF  x25
05C8:  MOVF   x1D,W
05CA:  MULWF  x19
05CC:  MOVF   FF3,W
05CE:  ADDWF  x16,W
05D0:  ADDWF  x1E,W
05D2:  MOVWF  x26
05D4:  MOVFF  125,127
05D8:  MOVWF  x28
05DA:  MOVFF  11A,129
05DE:  MOVLB  0
05E0:  RCALL  03C0
05E2:  MOVLB  1
05E4:  INCF   x1F,F
05E6:  BRA    05BC
....................                   } 
05E8:  INCF   x1E,F
05EA:  BRA    05B4
....................                } 
....................             } 
05EC:  INCF   x1D,F
05EE:  BRA    0580
....................          } 
05F0:  INCF   x1C,F
05F2:  MOVF   x19,W
05F4:  ADDWF  x15,F
05F6:  BRA    0578
....................       } 
05F8:  INCF   x1B,F
05FA:  INCF   x15,F
05FC:  BRA    047C
....................    } 
05FE:  MOVLB  0
0600:  GOTO   06E8 (RETURN)
.................... } 
....................  
....................  
.................... // Purpose:       Fill the LCD screen with the passed in color. 
.................... //                Works much faster than drawing a rectangle to fill the screen. 
.................... // Inputs:        ON - turn all the pixels on 
.................... //                OFF - turn all the pixels off 
.................... // Dependencies:  glcd_writeByte() 
.................... void glcd_fillScreen(int1 color) 
.................... { 
....................    int i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
*
0232:  MOVLB  1
0234:  CLRF   x14
0236:  MOVF   x14,W
0238:  SUBLW  07
023A:  BNC   02C4
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
023C:  BCF    F93.2
023E:  BCF    F8A.2
....................       glcd_writeByte(GLCD_CS1, 0b01000000);     // Set horizontal address to 0 
0240:  MOVLW  08
0242:  MOVWF  x2D
0244:  MOVLW  40
0246:  MOVWF  x2E
0248:  MOVLB  0
024A:  RCALL  0200
....................       glcd_writeByte(GLCD_CS2, 0b01000000); 
024C:  MOVLW  09
024E:  MOVLB  1
0250:  MOVWF  x2D
0252:  MOVLW  40
0254:  MOVWF  x2E
0256:  MOVLB  0
0258:  RCALL  0200
....................       glcd_writeByte(GLCD_CS1, i | 0b10111000); // Set page address 
025A:  MOVLB  1
025C:  MOVF   x14,W
025E:  IORLW  B8
0260:  MOVWF  x16
0262:  MOVLW  08
0264:  MOVWF  x2D
0266:  MOVFF  116,12E
026A:  MOVLB  0
026C:  RCALL  0200
....................       glcd_writeByte(GLCD_CS2, i | 0b10111000); 
026E:  MOVLB  1
0270:  MOVF   x14,W
0272:  IORLW  B8
0274:  MOVWF  x16
0276:  MOVLW  09
0278:  MOVWF  x2D
027A:  MOVFF  116,12E
027E:  MOVLB  0
0280:  RCALL  0200
....................       output_high(GLCD_DI);                     // Set for data 
0282:  BCF    F93.2
0284:  BSF    F8A.2
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
0286:  MOVLB  1
0288:  CLRF   x15
028A:  MOVF   x15,W
028C:  SUBLW  3F
028E:  BNC   02C0
....................       { 
....................          glcd_writeByte(GLCD_CS1, 0xFF*color);  // Turn pixels on or off 
0290:  MOVF   x13,W
0292:  MULLW  FF
0294:  MOVFF  FF3,116
0298:  MOVLW  08
029A:  MOVWF  x2D
029C:  MOVFF  116,12E
02A0:  MOVLB  0
02A2:  RCALL  0200
....................          glcd_writeByte(GLCD_CS2, 0xFF*color);  // Turn pixels on or off 
02A4:  MOVLB  1
02A6:  MOVF   x13,W
02A8:  MULLW  FF
02AA:  MOVFF  FF3,116
02AE:  MOVLW  09
02B0:  MOVWF  x2D
02B2:  MOVFF  116,12E
02B6:  MOVLB  0
02B8:  RCALL  0200
02BA:  MOVLB  1
02BC:  INCF   x15,F
02BE:  BRA    028A
....................       } 
02C0:  INCF   x14,F
02C2:  BRA    0236
....................    } 
02C4:  MOVLB  0
02C6:  RETURN 0
.................... } 
....................  
.................... // Purpose:       Write a byte of data to the specified chip 
.................... // Inputs:        chipSelect - which chip to write the data to 
.................... //                data - the byte of data to write 
....................  
.................... void glcd_writeByte(char chip, BYTE data) 
.................... { 
....................    if(chip == GLCD_CS1)       // Choose which chip to write to 
*
0200:  MOVLB  1
0202:  MOVF   x2D,W
0204:  SUBLW  08
0206:  BNZ   020E
....................       output_high(GLCD_CS1); 
0208:  BCF    F93.0
020A:  BSF    F8A.0
020C:  BRA    0212
....................    else 
....................       output_high(GLCD_CS2); 
020E:  BCF    F93.1
0210:  BSF    F8A.1
....................  
....................    output_low(GLCD_RW);       // Set for writing 
0212:  BCF    F93.4
0214:  BCF    F8A.4
....................    output_d(data);            // Put the data on the port 
0216:  CLRF   F95
0218:  MOVFF  12E,F8C
....................    output_high(GLCD_E);       // Pulse the enable pin 
021C:  BCF    F93.5
021E:  BSF    F8A.5
....................    delay_us(2); 
0220:  BRA    0222
....................    output_low(GLCD_E); 
0222:  BCF    F93.5
0224:  BCF    F8A.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
0226:  BCF    F93.0
0228:  BCF    F8A.0
....................    output_low(GLCD_CS2); 
022A:  BCF    F93.1
022C:  BCF    F8A.1
022E:  MOVLB  0
0230:  RETURN 0
.................... } 
....................  
....................  
.................... // Purpose:       Reads a byte of data from the specified chip 
.................... // Ouputs:        A byte of data read from the chip 
.................... BYTE glcd_readByte(BYTE chip) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................    if(chip == GLCD_CS1)       // Choose which chip to read from 
*
037A:  MOVLB  1
037C:  MOVF   x2C,W
037E:  SUBLW  08
0380:  BNZ   0388
....................       output_high(GLCD_CS1); 
0382:  BCF    F93.0
0384:  BSF    F8A.0
0386:  BRA    038C
....................    else 
....................       output_high(GLCD_CS2); 
0388:  BCF    F93.1
038A:  BSF    F8A.1
....................  
....................    input_d();                 // Set port d to input 
038C:  SETF   F95
....................    output_high(GLCD_RW);      // Set for reading 
038E:  BCF    F93.4
0390:  BSF    F8A.4
....................    output_high(GLCD_E);       // Pulse the enable pin 
0392:  BCF    F93.5
0394:  BSF    F8A.5
....................    delay_us(2); 
0396:  BRA    0398
....................    output_low(GLCD_E); 
0398:  BCF    F93.5
039A:  BCF    F8A.5
....................    delay_us(2); 
039C:  BRA    039E
....................    output_high(GLCD_E);       // Pulse the enable pin 
039E:  BCF    F93.5
03A0:  BSF    F8A.5
....................    delay_us(2); 
03A2:  BRA    03A4
....................    data = input_d();          // Get the data from the display's output register 
03A4:  SETF   F95
03A6:  MOVFF  F83,12D
....................    output_low(GLCD_E); 
03AA:  BCF    F93.5
03AC:  BCF    F8A.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
03AE:  BCF    F93.0
03B0:  BCF    F8A.0
....................    output_low(GLCD_CS2); 
03B2:  BCF    F93.1
03B4:  BCF    F8A.1
....................    return data;               // Return the read data 
03B6:  MOVFF  12D,01
03BA:  MOVLB  0
03BC:  GOTO   0412 (RETURN)
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #define direita   0 
.................... #define dir       pin_c1 
.................... #define cima      1 
.................... #define cim       pin_c2 
.................... #define esquerda  2 
.................... #define esq       pin_c4 
.................... #define baixo     3 
.................... #define bai       pin_c5 
.................... char yl[10] = "You Lose!"; 
.................... struct Dot{ 
....................    unsigned int x; 
....................    unsigned int y; 
.................... }; 
.................... struct Dot snake[128]; 
.................... struct Dot point; 
.................... int8   sentido; 
.................... int8   size=10; 
....................  
.................... void mov(){ 
....................    int8 i; 
....................    struct Dot aux; 
....................    aux.x = snake[0].x; 
*
062E:  MOVFF  0E,113
....................    aux.y = snake[0].y; 
0632:  MOVFF  0F,114
....................    switch (sentido){ 
0636:  MOVLB  1
0638:  MOVF   x10,W
063A:  ADDLW  FC
063C:  BC    0688
063E:  ADDLW  04
0640:  MOVLB  0
0642:  GOTO   07C8
....................       case direita: 
....................          if(aux.x==127) 
0646:  MOVLB  1
0648:  MOVF   x13,W
064A:  SUBLW  7F
064C:  BNZ   0652
....................             aux.x=0; 
064E:  CLRF   x13
0650:  BRA    0654
....................          else 
....................             aux.x++; 
0652:  INCF   x13,F
....................       break; 
0654:  BRA    0688
....................       case cima: 
....................          if(aux.y==0) 
0656:  MOVLB  1
0658:  MOVF   x14,F
065A:  BNZ   0662
....................             aux.y=63; 
065C:  MOVLW  3F
065E:  MOVWF  x14
0660:  BRA    0664
....................          else 
....................             aux.y--; 
0662:  DECF   x14,F
....................       break; 
0664:  BRA    0688
....................       case esquerda: 
....................          if(aux.x==0) 
0666:  MOVLB  1
0668:  MOVF   x13,F
066A:  BNZ   0672
....................             aux.x=127; 
066C:  MOVLW  7F
066E:  MOVWF  x13
0670:  BRA    0674
....................          else 
....................             aux.x--; 
0672:  DECF   x13,F
....................       break; 
0674:  BRA    0688
....................       case baixo: 
....................          if(aux.y==63) 
0676:  MOVLB  1
0678:  MOVF   x14,W
067A:  SUBLW  3F
067C:  BNZ   0682
....................             aux.y=0; 
067E:  CLRF   x14
0680:  BRA    0684
....................          else 
....................             aux.y++; 
0682:  INCF   x14,F
....................       break; 
0684:  BRA    0688
0686:  MOVLB  1
....................    } 
....................    for(i=1;i<size;i++){ 
0688:  MOVLW  01
068A:  MOVWF  x12
068C:  MOVF   x11,W
068E:  SUBWF  x12,W
0690:  BC    0702
....................       if(aux.x==snake[i].x && aux.y==snake[i].y){ 
0692:  BCF    FD8.0
0694:  RLCF   x12,W
0696:  CLRF   x16
0698:  MOVWF  x15
069A:  MOVLW  0E
069C:  ADDWF  x15,W
069E:  MOVWF  FE9
06A0:  MOVLW  00
06A2:  ADDWFC x16,W
06A4:  MOVWF  FEA
06A6:  MOVF   FEF,W
06A8:  SUBWF  x13,W
06AA:  BNZ   06FE
06AC:  BCF    FD8.0
06AE:  RLCF   x12,W
06B0:  CLRF   x18
06B2:  MOVWF  x17
06B4:  MOVLW  01
06B6:  ADDWF  x17,W
06B8:  MOVWF  01
06BA:  MOVLW  00
06BC:  ADDWFC x18,W
06BE:  MOVWF  03
06C0:  MOVF   01,W
06C2:  ADDLW  0E
06C4:  MOVWF  FE9
06C6:  MOVLW  00
06C8:  ADDWFC 03,W
06CA:  MOVWF  FEA
06CC:  MOVF   FEF,W
06CE:  SUBWF  x14,W
06D0:  BNZ   06FE
....................          glcd_text57(0,0,yl,2,1); 
06D2:  CLRF   x15
06D4:  CLRF   x16
06D6:  CLRF   x18
06D8:  MOVLW  04
06DA:  MOVWF  x17
06DC:  MOVLW  02
06DE:  MOVWF  x19
06E0:  MOVLW  01
06E2:  MOVWF  x1A
06E4:  MOVLB  0
06E6:  BRA    0478
....................          delay_ms(1000); 
06E8:  MOVLW  04
06EA:  MOVLB  1
06EC:  MOVWF  x15
06EE:  MOVLW  FA
06F0:  MOVWF  x16
06F2:  MOVLB  0
06F4:  RCALL  0604
06F6:  MOVLB  1
06F8:  DECFSZ x15,F
06FA:  BRA    06EE
....................          return; 
06FC:  BRA    07C2
....................       } 
06FE:  INCF   x12,F
0700:  BRA    068C
....................    } 
....................    if(aux.x==point.x && aux.y==point.y){ 
0702:  MOVF   x0E,W
0704:  SUBWF  x13,W
0706:  BNZ   0710
0708:  MOVF   x0F,W
070A:  SUBWF  x14,W
070C:  BNZ   0710
....................       size++; 
070E:  INCF   x11,F
....................    } 
....................    for(i=size;i>0;i--){ 
0710:  MOVFF  111,112
0714:  MOVF   x12,F
0716:  BZ    07BA
....................       snake[i].x=snake[i-1].x; 
0718:  BCF    FD8.0
071A:  RLCF   x12,W
071C:  CLRF   x16
071E:  MOVWF  x15
0720:  MOVLW  0E
0722:  ADDWF  x15,W
0724:  MOVWF  01
0726:  MOVLW  00
0728:  ADDWFC x16,W
072A:  MOVWF  03
072C:  MOVLW  01
072E:  SUBWF  x12,W
0730:  MOVWF  00
0732:  BCF    FD8.0
0734:  RLCF   00,F
0736:  MOVF   00,W
0738:  CLRF   x1A
073A:  MOVWF  x19
073C:  MOVLW  0E
073E:  ADDWF  x19,W
0740:  MOVWF  FE9
0742:  MOVLW  00
0744:  ADDWFC x1A,W
0746:  MOVWF  FEA
0748:  MOVFF  FEF,11B
074C:  MOVFF  03,FEA
0750:  MOVFF  01,FE9
0754:  MOVFF  11B,FEF
....................       snake[i].y=snake[i-1].y; 
0758:  BCF    FD8.0
075A:  RLCF   x12,W
075C:  CLRF   x16
075E:  MOVWF  x15
0760:  MOVLW  01
0762:  ADDWF  x15,W
0764:  MOVWF  01
0766:  MOVLW  00
0768:  ADDWFC x16,W
076A:  MOVWF  03
076C:  MOVF   01,W
076E:  ADDLW  0E
0770:  MOVWF  01
0772:  MOVLW  00
0774:  ADDWFC 03,F
0776:  MOVFF  01,115
077A:  MOVFF  03,116
077E:  MOVLW  01
0780:  SUBWF  x12,W
0782:  MOVWF  00
0784:  BCF    FD8.0
0786:  RLCF   00,F
0788:  MOVF   00,W
078A:  CLRF   x18
078C:  MOVWF  x17
078E:  MOVLW  01
0790:  ADDWF  x17,W
0792:  MOVWF  01
0794:  MOVLW  00
0796:  ADDWFC x18,W
0798:  MOVWF  03
079A:  MOVF   01,W
079C:  ADDLW  0E
079E:  MOVWF  FE9
07A0:  MOVLW  00
07A2:  ADDWFC 03,W
07A4:  MOVWF  FEA
07A6:  MOVFF  FEF,117
07AA:  MOVFF  116,FEA
07AE:  MOVFF  115,FE9
07B2:  MOVFF  117,FEF
07B6:  DECF   x12,F
07B8:  BRA    0714
....................    } 
....................    snake[0].x=aux.x; 
07BA:  MOVFF  113,0E
....................    snake[0].y=aux.y; 
07BE:  MOVFF  114,0F
07C2:  MOVLB  0
07C4:  GOTO   0958 (RETURN)
.................... } 
....................  
.................... void draw(){ 
....................    int8 i; 
....................    glcd_fillScreen(0); 
*
07EA:  MOVLB  1
07EC:  CLRF   x13
07EE:  MOVLB  0
07F0:  RCALL  0232
....................    for(i=1;i<size;i++){ 
07F2:  MOVLW  01
07F4:  MOVLB  1
07F6:  MOVWF  x12
07F8:  MOVF   x11,W
07FA:  SUBWF  x12,W
07FC:  BC    0850
....................       glcd_pixel(snake[i].x,snake[i].y,1); 
07FE:  BCF    FD8.0
0800:  RLCF   x12,W
0802:  CLRF   x14
0804:  MOVWF  x13
0806:  MOVLW  0E
0808:  ADDWF  x13,W
080A:  MOVWF  FE9
080C:  MOVLW  00
080E:  ADDWFC x14,W
0810:  MOVWF  FEA
0812:  MOVFF  FEF,115
0816:  BCF    FD8.0
0818:  RLCF   x12,W
081A:  CLRF   x17
081C:  MOVWF  x16
081E:  MOVLW  01
0820:  ADDWF  x16,W
0822:  MOVWF  01
0824:  MOVLW  00
0826:  ADDWFC x17,W
0828:  MOVWF  03
082A:  MOVF   01,W
082C:  ADDLW  0E
082E:  MOVWF  FE9
0830:  MOVLW  00
0832:  ADDWFC 03,W
0834:  MOVWF  FEA
0836:  MOVFF  FEF,116
083A:  MOVFF  115,127
083E:  MOVFF  116,128
0842:  MOVLW  01
0844:  MOVWF  x29
0846:  MOVLB  0
0848:  RCALL  03C0
084A:  MOVLB  1
084C:  INCF   x12,F
084E:  BRA    07F8
....................    } 
....................    glcd_pixel(point.x,point.y,1); 
0850:  MOVFF  10E,127
0854:  MOVFF  10F,128
0858:  MOVLW  01
085A:  MOVWF  x29
085C:  MOVLB  0
085E:  RCALL  03C0
0860:  GOTO   095A (RETURN)
.................... } 
....................  
.................... void main(){ 
0864:  CLRF   FF8
0866:  BCF    FD0.7
0868:  MOVLW  0A
086A:  MOVLB  1
086C:  MOVWF  x11
086E:  MOVF   FC1,W
0870:  ANDLW  C0
0872:  IORLW  0F
0874:  MOVWF  FC1
0876:  MOVLW  07
0878:  MOVWF  FB4
087A:  MOVLW  59
087C:  MOVWF  04
087E:  MOVLW  6F
0880:  MOVWF  05
0882:  MOVLW  75
0884:  MOVWF  06
0886:  MOVLW  20
0888:  MOVWF  07
088A:  MOVLW  4C
088C:  MOVWF  08
088E:  MOVLW  6F
0890:  MOVWF  09
0892:  MOVLW  73
0894:  MOVWF  0A
0896:  MOVLW  65
0898:  MOVWF  0B
089A:  MOVLW  21
089C:  MOVWF  0C
089E:  CLRF   0D
....................    setup_adc_ports(AN0); 
08A0:  MOVF   FC1,W
08A2:  ANDLW  C0
08A4:  IORLW  0E
08A6:  MOVWF  FC1
....................    setup_adc(ADC_CLOCK_INTERNAL|ADC_TAD_MUL_0); 
08A8:  MOVF   FC0,W
08AA:  ANDLW  C0
08AC:  IORLW  07
08AE:  MOVWF  FC0
08B0:  BCF    FC0.7
08B2:  BSF    FC2.0
....................    setup_psp(PSP_DISABLED); 
08B4:  BCF    F96.4
....................    setup_spi(SPI_SS_DISABLED); 
08B6:  BCF    FC6.5
08B8:  BCF    F94.7
08BA:  BSF    F93.0
08BC:  BCF    F93.1
08BE:  MOVLW  01
08C0:  MOVWF  FC6
08C2:  MOVLW  00
08C4:  MOVWF  FC7
....................    setup_wdt(WDT_OFF); 
08C6:  BCF    FD1.0
....................    setup_timer_0(RTCC_INTERNAL); 
08C8:  MOVLW  80
08CA:  MOVWF  FD5
....................    setup_timer_1(T1_DISABLED); 
08CC:  CLRF   FCD
....................    setup_timer_2(T2_DISABLED,0,1); 
08CE:  MOVLW  00
08D0:  MOVWF  FCA
08D2:  MOVLW  00
08D4:  MOVWF  FCB
....................    setup_timer_3(T3_DISABLED|T3_DIV_BY_1); 
08D6:  CLRF   FB1
....................  
....................    glcd_init(ON);   //inicializa o display 
08D8:  MOVLW  01
08DA:  MOVWF  x12
08DC:  MOVLB  0
08DE:  BRA    02C8
....................    glcd_fillScreen(0); //limpa display inteiro 
08E0:  MOVLB  1
08E2:  CLRF   x13
08E4:  MOVLB  0
08E6:  RCALL  0232
....................  
....................    snake[0].x = 64; 
08E8:  MOVLW  40
08EA:  MOVWF  0E
....................    snake[0].y = 32; 
08EC:  MOVLW  20
08EE:  MOVWF  0F
....................    snake[1].x = 63; 
08F0:  MOVLW  3F
08F2:  MOVWF  10
....................    snake[1].y = 32; 
08F4:  MOVLW  20
08F6:  MOVWF  11
....................    snake[2].x = 62; 
08F8:  MOVLW  3E
08FA:  MOVWF  12
....................    snake[2].y = 32; 
08FC:  MOVLW  20
08FE:  MOVWF  13
....................    snake[3].x = 61; 
0900:  MOVLW  3D
0902:  MOVWF  14
....................    snake[3].y = 32; 
0904:  MOVLW  20
0906:  MOVWF  15
....................     
....................    point.x = 50; 
0908:  MOVLW  32
090A:  MOVLB  1
090C:  MOVWF  x0E
....................    point.y = 32; 
090E:  MOVLW  20
0910:  MOVWF  x0F
....................    while(TRUE){ 
....................       if(input(dir)){ 
0912:  BSF    F94.1
0914:  BTFSS  F82.1
0916:  BRA    0922
....................          if(sentido!=esquerda) 
0918:  MOVF   x10,W
091A:  SUBLW  02
091C:  BZ    0920
....................             sentido = direita; 
091E:  CLRF   x10
....................       } 
0920:  BRA    0954
....................       else if(input(cim)){ 
0922:  BSF    F94.2
0924:  BTFSS  F82.2
0926:  BRA    0934
....................          if(sentido!=baixo) 
0928:  MOVF   x10,W
092A:  SUBLW  03
092C:  BZ    0932
....................             sentido = cima; 
092E:  MOVLW  01
0930:  MOVWF  x10
....................       } 
0932:  BRA    0954
....................       else if(input(esq)){ 
0934:  BSF    F94.4
0936:  BTFSS  F82.4
0938:  BRA    0944
....................          if(sentido!=direita) 
093A:  MOVF   x10,F
093C:  BZ    0942
....................             sentido = esquerda; 
093E:  MOVLW  02
0940:  MOVWF  x10
....................       } 
0942:  BRA    0954
....................       else if(input(bai)){ 
0944:  BSF    F94.5
0946:  BTFSS  F82.5
0948:  BRA    0954
....................          if(sentido!=cima) 
094A:  DECFSZ x10,W
094C:  BRA    0950
094E:  BRA    0954
....................             sentido = baixo; 
0950:  MOVLW  03
0952:  MOVWF  x10
....................       } 
....................       mov(); 
0954:  MOVLB  0
0956:  BRA    062E
....................       draw(); 
0958:  BRA    07EA
....................       delay_ms(10); 
095A:  MOVLW  0A
095C:  MOVLB  1
095E:  MOVWF  x16
0960:  MOVLB  0
0962:  RCALL  0604
0964:  MOVLB  1
0966:  BRA    0912
....................    } 
.................... } 
.................... /*    int n;               //circle test 
0968:  SLEEP 
....................       for(n=0;n<32;n+=3){ 
....................          glcd_circle(64, 32, n, NO, 1); 
....................          delay_ms(100); 
....................       } 
....................       glcd_fillScreen(1); 
....................       for(n=0;n<32;n+=3){ 
....................          glcd_circle(64, 32, n, NO, 0); 
....................          delay_ms(100); 
....................       } 
....................       glcd_fillScreen(0);*/ 
....................        
.................... /*    char Str1[20];       //text test 
....................       Str1 = "Loren Ipsun"; 
....................       int n; 
....................       for(n=0;n<4;n++){ 
....................          glcd_fillScreen(0); 
....................          glcd_text57(0,0,Str1,n,1); 
....................          delay_ms(500); 
....................       }*/ 
....................        
.................... /*    int x,y;       //lazy clock 
....................       float a; 
....................       for(a=0;a<6.2831;a+=0.0523598){ 
....................          y=(float)-30*cos(a); 
....................          x=(float)30*sin(a); 
....................          y+=32; 
....................          x+=64; 
....................          glcd_fillScreen(0); 
....................          glcd_circle(64, 32, 32, NO, 1); 
....................          glcd_line(64,32,x,y,1); 
....................          delay_ms(500); 
....................       }*/ 
....................        
.................... /* set_adc_channel(0);     //osciloscope 
....................    int8 xa,x,n=0; 
....................    char pt[10],pv[10]; 
....................    pt = "100ms"; 
....................    pv = "78.25v"; 
....................    glcd_text57(0,57,pv,1,1); 
....................    glcd_text57(90,57,pt,1,1); 
....................    while(TRUE){ 
....................       n++; 
....................       if(n>127){ 
....................          n=1; 
....................          glcd_fillScreen(0); 
....................          glcd_text57(0,57,pv,1,1); 
....................          glcd_text57(90,57,pt,1,1); 
....................       } 
....................       xa=x; 
....................       x=read_adc()/4; 
....................       glcd_line(n-1,xa,n,x,1); 
....................       delay_ms(100); 
....................    }*/ 

Configuration Fuses:
   Word  1: C000   PLL1 CPUDIV1 NOUSBDIV XT FCMEN IESO
   Word  2: 0E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT128
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
