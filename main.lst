CCS PCH C Compiler, Version 5.015, 5967               30-dez-15 01:46

               Filename:   D:\pasta\14\Grafic LCD\snake glcd\main.lst

               ROM used:   2452 bytes (7%)
                           Largest free fragment is 30316
               RAM used:   276 (13%) at main() level
                           303 (15%) worst case
               Stack used: 4 locations
               Stack size: 31

*
0000:  GOTO   0880
.................... #include <18F4550.h> 
.................... //////////// Standard Header file for the PIC18F4550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4550 
0004:  CLRF   FF7
0006:  ADDLW  14
0008:  MOVWF  FF6
000A:  MOVLW  00
000C:  ADDWFC FF7,F
000E:  TBLRD*+
0010:  MOVF   FF5,W
0012:  RETURN 0
0014:  DATA 00,00
0016:  DATA 00,00
0018:  DATA 00,00
001A:  DATA 00,5F
001C:  DATA 00,00
001E:  DATA 00,03
0020:  DATA 00,03
0022:  DATA 00,14
0024:  DATA 3E,14
0026:  DATA 3E,14
0028:  DATA 24,2A
002A:  DATA 7F,2A
002C:  DATA 12,43
002E:  DATA 33,08
0030:  DATA 66,61
0032:  DATA 36,49
0034:  DATA 55,22
0036:  DATA 50,00
0038:  DATA 05,03
003A:  DATA 00,00
003C:  DATA 00,1C
003E:  DATA 22,41
0040:  DATA 00,00
0042:  DATA 41,22
0044:  DATA 1C,00
0046:  DATA 14,08
0048:  DATA 3E,08
004A:  DATA 14,08
004C:  DATA 08,3E
004E:  DATA 08,08
0050:  DATA 00,50
0052:  DATA 30,00
0054:  DATA 00,08
0056:  DATA 08,08
0058:  DATA 08,08
005A:  DATA 00,60
005C:  DATA 60,00
005E:  DATA 00,20
0060:  DATA 10,08
0062:  DATA 04,02
0064:  DATA 3E,51
0066:  DATA 49,45
0068:  DATA 3E,04
006A:  DATA 02,7F
006C:  DATA 00,00
006E:  DATA 42,61
0070:  DATA 51,49
0072:  DATA 46,22
0074:  DATA 41,49
0076:  DATA 49,36
0078:  DATA 18,14
007A:  DATA 12,7F
007C:  DATA 10,27
007E:  DATA 45,45
0080:  DATA 45,39
0082:  DATA 3E,49
0084:  DATA 49,49
0086:  DATA 32,01
0088:  DATA 01,71
008A:  DATA 09,07
008C:  DATA 36,49
008E:  DATA 49,49
0090:  DATA 36,26
0092:  DATA 49,49
0094:  DATA 49,3E
0096:  DATA 00,36
0098:  DATA 36,00
009A:  DATA 00,00
009C:  DATA 56,36
009E:  DATA 00,00
00A0:  DATA 08,14
00A2:  DATA 22,41
00A4:  DATA 00,14
00A6:  DATA 14,14
00A8:  DATA 14,14
00AA:  DATA 00,41
00AC:  DATA 22,14
00AE:  DATA 08,02
00B0:  DATA 01,51
00B2:  DATA 09,06
00B4:  DATA 3E,41
00B6:  DATA 59,55
00B8:  DATA 5E,7E
00BA:  DATA 09,09
00BC:  DATA 09,7E
00BE:  DATA 7F,49
00C0:  DATA 49,49
00C2:  DATA 36,3E
00C4:  DATA 41,41
00C6:  DATA 41,22
00C8:  DATA 7F,41
00CA:  DATA 41,41
00CC:  DATA 3E,7F
00CE:  DATA 49,49
00D0:  DATA 49,41
00D2:  DATA 7F,09
00D4:  DATA 09,09
00D6:  DATA 01,3E
00D8:  DATA 41,41
00DA:  DATA 49,3A
00DC:  DATA 7F,08
00DE:  DATA 08,08
00E0:  DATA 7F,00
00E2:  DATA 41,7F
00E4:  DATA 41,00
00E6:  DATA 30,40
00E8:  DATA 40,40
00EA:  DATA 3F,7F
00EC:  DATA 08,14
00EE:  DATA 22,41
00F0:  DATA 7F,40
00F2:  DATA 40,40
00F4:  DATA 40,7F
00F6:  DATA 02,0C
00F8:  DATA 02,7F
00FA:  DATA 7F,02
00FC:  DATA 04,08
00FE:  DATA 7F,3E
0100:  DATA 41,41
0102:  DATA 41,3E
0104:  DATA 7F,09
0106:  DATA 09,09
0108:  DATA 06,1E
010A:  DATA 21,21
010C:  DATA 21,5E
010E:  DATA 7F,09
0110:  DATA 09,09
0112:  DATA 76,00
0114:  CLRF   FF7
0116:  ADDLW  24
0118:  MOVWF  FF6
011A:  MOVLW  01
011C:  ADDWFC FF7,F
011E:  TBLRD*+
0120:  MOVF   FF5,W
0122:  RETURN 0
0124:  DATA 26,49
0126:  DATA 49,49
0128:  DATA 32,01
012A:  DATA 01,7F
012C:  DATA 01,01
012E:  DATA 3F,40
0130:  DATA 40,40
0132:  DATA 3F,1F
0134:  DATA 20,40
0136:  DATA 20,1F
0138:  DATA 7F,20
013A:  DATA 10,20
013C:  DATA 7F,41
013E:  DATA 22,1C
0140:  DATA 22,41
0142:  DATA 07,08
0144:  DATA 70,08
0146:  DATA 07,61
0148:  DATA 51,49
014A:  DATA 45,43
014C:  DATA 00,7F
014E:  DATA 41,00
0150:  DATA 00,02
0152:  DATA 04,08
0154:  DATA 10,20
0156:  DATA 00,00
0158:  DATA 41,7F
015A:  DATA 00,04
015C:  DATA 02,01
015E:  DATA 02,04
0160:  DATA 40,40
0162:  DATA 40,40
0164:  DATA 40,00
0166:  DATA 01,02
0168:  DATA 04,00
016A:  DATA 20,54
016C:  DATA 54,54
016E:  DATA 78,7F
0170:  DATA 44,44
0172:  DATA 44,38
0174:  DATA 38,44
0176:  DATA 44,44
0178:  DATA 44,38
017A:  DATA 44,44
017C:  DATA 44,7F
017E:  DATA 38,54
0180:  DATA 54,54
0182:  DATA 18,04
0184:  DATA 04,7E
0186:  DATA 05,05
0188:  DATA 08,54
018A:  DATA 54,54
018C:  DATA 3C,7F
018E:  DATA 08,04
0190:  DATA 04,78
0192:  DATA 00,44
0194:  DATA 7D,40
0196:  DATA 00,20
0198:  DATA 40,44
019A:  DATA 3D,00
019C:  DATA 7F,10
019E:  DATA 28,44
01A0:  DATA 00,00
01A2:  DATA 41,7F
01A4:  DATA 40,00
01A6:  DATA 7C,04
01A8:  DATA 78,04
01AA:  DATA 78,7C
01AC:  DATA 08,04
01AE:  DATA 04,78
01B0:  DATA 38,44
01B2:  DATA 44,44
01B4:  DATA 38,7C
01B6:  DATA 14,14
01B8:  DATA 14,08
01BA:  DATA 08,14
01BC:  DATA 14,14
01BE:  DATA 7C,00
01C0:  DATA 7C,08
01C2:  DATA 04,04
01C4:  DATA 48,54
01C6:  DATA 54,54
01C8:  DATA 20,04
01CA:  DATA 04,3F
01CC:  DATA 44,44
01CE:  DATA 3C,40
01D0:  DATA 40,20
01D2:  DATA 7C,1C
01D4:  DATA 20,40
01D6:  DATA 20,1C
01D8:  DATA 3C,40
01DA:  DATA 30,40
01DC:  DATA 3C,44
01DE:  DATA 28,10
01E0:  DATA 28,44
01E2:  DATA 0C,50
01E4:  DATA 50,50
01E6:  DATA 3C,44
01E8:  DATA 64,54
01EA:  DATA 4C,44
01EC:  DATA 00,08
01EE:  DATA 36,41
01F0:  DATA 41,00
01F2:  DATA 00,7F
01F4:  DATA 00,00
01F6:  DATA 41,41
01F8:  DATA 36,08
01FA:  DATA 00,02
01FC:  DATA 01,02
01FE:  DATA 04,02
*
085E:  ADDWF  FE8,W
0860:  CLRF   FF7
0862:  RLCF   FF7,F
0864:  ADDLW  79
0866:  MOVWF  FF6
0868:  MOVLW  08
086A:  ADDWFC FF7,F
086C:  TBLRD*-
086E:  MOVF   FF5,W
0870:  MOVWF  FFA
0872:  TBLRD*
0874:  MOVF   FF5,W
0876:  MOVWF  FF9
0878:  DATA 46,06
087A:  DATA 56,06
087C:  DATA 66,06
087E:  DATA 76,06
....................  
.................... #list 
....................  
.................... #device ADC=8 
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
....................  
.................... #use delay(clock=4MHz,crystal=4MHz) 
*
0604:  MOVLW  01
0606:  MOVWF  FEA
0608:  MOVLW  16
060A:  MOVWF  FE9
060C:  MOVF   FEF,W
060E:  BZ    062C
0610:  MOVLW  01
0612:  MOVWF  01
0614:  CLRF   00
0616:  DECFSZ 00,F
0618:  BRA    0616
061A:  DECFSZ 01,F
061C:  BRA    0614
061E:  MOVLW  4A
0620:  MOVWF  00
0622:  DECFSZ 00,F
0624:  BRA    0622
0626:  BRA    0628
0628:  DECFSZ FEF,F
062A:  BRA    0610
062C:  RETURN 0
....................  
.................... //bibliotecas 
.................... #include <GLCD.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           GLCD.C                                //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// an LED backlight. The HDM64GS12 is 128 pixles across and 64     //// 
.................... //// pixels down. The driver treats the upper left pixel as (0,0).   //// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... //// (These can be changed as needed in the following defines).      //// 
.................... ////  * 1: VSS is connected to GND                                   //// 
.................... ////  * 2: VDD is connected to +5V                                   //// 
.................... ////  * 3: V0 - LCD operating voltage is connected from a 20k Ohm POT//// 
.................... ////  * 4: D/I - Data or Instruction is connected to B2              //// 
.................... ////  * 5: R/W - Read or Write is connected to B4                    //// 
.................... ////  * 6: Enable is connected to B5                                 //// 
.................... ////  *7-14: Data Bus 0 to 7 is connected to port d                  //// 
.................... ////  *15: Chip Select 1 is connected to B0                          //// 
.................... ////  *16: Chip Select 2 is connected to B1                          //// 
.................... ////  *17: Reset is connected to C0                                  //// 
.................... ////  *18: Negative voltage is also connected to the 20k Ohm POT     //// 
.................... ////  *19: Positive voltage for LED backlight is connected to +5V    //// 
.................... ////  *20: Negavtive voltage for LED backlight is connected to GND   //// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1,y1,x2,y2,color)                                   //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color.                                     //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1,y1,x2,y2,fill,color)                              //// 
.................... ////     * Draws a rectangle with upper left point (x1,y1) and lower //// 
.................... ////       right point (x2,y2).                                      //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1,y1,x2,y2,width,color)                              //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point.                                             //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x,y,radius,fill,color)                             //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x,y,textptr,size,color)                            //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y).//// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall.           //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - The given text is character wrapped. If this       //// 
.................... ////       function is used on a different size display, then change //// 
.................... ////       the GLCD_WIDTH define appropriately.                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
....................  
.................... #ifndef GLCD_C 
.................... #define GLCD_C 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH 128    // Used for text wrapping by glcd_text57 function 
.................... #endif 
....................  
.................... #define ON  1 
.................... #define OFF 0 
....................  
.................... #define YES 1 
.................... #define NO  0 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1 PIN_B0   // Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2 PIN_B1   // Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_DI 
.................... #define GLCD_DI  PIN_B2   // Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW  PIN_B4   // Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E   PIN_B5   // Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST PIN_C0   // Reset 
.................... #endif 
....................  
....................  
....................  
.................... BYTE glcd_readByte(BYTE chip); 
.................... void glcd_writeByte(BYTE chip, BYTE data); 
.................... void glcd_fillScreen(int1 color); 
....................  
.................... const BYTE TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
....................  
.................... // Purpose:       Initialize a graphic LCD. This must be called before any 
.................... //                other glcd function is used. 
.................... // Inputs:        The initialization mode 
.................... //                OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... // Date:          5/28/2003 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
*
02C8:  BCF    F94.0
02CA:  BSF    F8B.0
....................    output_low(GLCD_E); 
02CC:  BCF    F93.5
02CE:  BCF    F8A.5
....................    output_low(GLCD_CS1); 
02D0:  BCF    F93.0
02D2:  BCF    F8A.0
....................    output_low(GLCD_CS2); 
02D4:  BCF    F93.1
02D6:  BCF    F8A.1
....................  
....................    output_low(GLCD_DI);                // Set for instruction 
02D8:  BCF    F93.2
02DA:  BCF    F8A.2
....................    glcd_writeByte(GLCD_CS1, 0xC0);     // Specify first RAM line at the top 
02DC:  MOVLW  08
02DE:  MOVLB  1
02E0:  MOVWF  x2D
02E2:  MOVLW  C0
02E4:  MOVWF  x2E
02E6:  MOVLB  0
02E8:  RCALL  0200
....................    glcd_writeByte(GLCD_CS2, 0xC0);     //   of the screen 
02EA:  MOVLW  09
02EC:  MOVLB  1
02EE:  MOVWF  x2D
02F0:  MOVLW  C0
02F2:  MOVWF  x2E
02F4:  MOVLB  0
02F6:  RCALL  0200
....................    glcd_writeByte(GLCD_CS1, 0x40);     // Set the column address to 0 
02F8:  MOVLW  08
02FA:  MOVLB  1
02FC:  MOVWF  x2D
02FE:  MOVLW  40
0300:  MOVWF  x2E
0302:  MOVLB  0
0304:  RCALL  0200
....................    glcd_writeByte(GLCD_CS2, 0x40); 
0306:  MOVLW  09
0308:  MOVLB  1
030A:  MOVWF  x2D
030C:  MOVLW  40
030E:  MOVWF  x2E
0310:  MOVLB  0
0312:  RCALL  0200
....................    glcd_writeByte(GLCD_CS1, 0xB8);     // Set the page address to 0 
0314:  MOVLW  08
0316:  MOVLB  1
0318:  MOVWF  x2D
031A:  MOVLW  B8
031C:  MOVWF  x2E
031E:  MOVLB  0
0320:  RCALL  0200
....................    glcd_writeByte(GLCD_CS2, 0xB8); 
0322:  MOVLW  09
0324:  MOVLB  1
0326:  MOVWF  x2D
0328:  MOVLW  B8
032A:  MOVWF  x2E
032C:  MOVLB  0
032E:  RCALL  0200
....................    if(mode == ON) 
0330:  MOVLB  1
0332:  DECFSZ x12,W
0334:  BRA    0354
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3F);  // Turn the display on 
0336:  MOVLW  08
0338:  MOVWF  x2D
033A:  MOVLW  3F
033C:  MOVWF  x2E
033E:  MOVLB  0
0340:  RCALL  0200
....................       glcd_writeByte(GLCD_CS2, 0x3F); 
0342:  MOVLW  09
0344:  MOVLB  1
0346:  MOVWF  x2D
0348:  MOVLW  3F
034A:  MOVWF  x2E
034C:  MOVLB  0
034E:  RCALL  0200
....................    } 
0350:  BRA    036E
0352:  MOVLB  1
....................    else 
....................    { 
....................       glcd_writeByte(GLCD_CS1, 0x3E);  // Turn the display off 
0354:  MOVLW  08
0356:  MOVWF  x2D
0358:  MOVLW  3E
035A:  MOVWF  x2E
035C:  MOVLB  0
035E:  RCALL  0200
....................       glcd_writeByte(GLCD_CS2, 0x3E); 
0360:  MOVLW  09
0362:  MOVLB  1
0364:  MOVWF  x2D
0366:  MOVLW  3E
0368:  MOVWF  x2E
036A:  MOVLB  0
036C:  RCALL  0200
....................    } 
....................  
....................    glcd_fillScreen(OFF);               // Clear the display 
036E:  MOVLB  1
0370:  CLRF   x13
0372:  MOVLB  0
0374:  RCALL  0232
0376:  GOTO   08FC (RETURN)
.................... } 
....................  
....................  
.................... // Purpose:       Turn a pixel on a graphic LCD on or off 
.................... // Inputs:        x - the x coordinate of the pixel 
.................... //                y - the y coordinate of the pixel 
.................... //                color - ON or OFF 
.................... // Output:        1 if coordinate out of range, 0 if in range 
.................... void glcd_pixel(int x, int y, int1 color) 
*
03C0:  MOVLW  08
03C2:  MOVLB  1
03C4:  MOVWF  x2B
.................... { 
....................    BYTE data; 
....................    BYTE chip = GLCD_CS1;  // Stores which chip to use on the LCD 
....................  
....................    if(x > 63)  // Check for first or second display area 
03C6:  MOVF   x27,W
03C8:  SUBLW  3F
03CA:  BC    03D4
....................    { 
....................       x -= 64; 
03CC:  MOVLW  40
03CE:  SUBWF  x27,F
....................       chip = GLCD_CS2; 
03D0:  MOVLW  09
03D2:  MOVWF  x2B
....................    } 
....................  
....................    output_low(GLCD_DI);                                     // Set for instruction 
03D4:  BCF    F93.2
03D6:  BCF    F8A.2
....................    bit_clear(x,7);                                          // Clear the MSB. Part of an instruction code 
03D8:  BCF    x27.7
....................    bit_set(x,6);                                            // Set bit 6. Also part of an instruction code 
03DA:  BSF    x27.6
....................    glcd_writeByte(chip, x);                                 // Set the horizontal address 
03DC:  MOVFF  12B,12D
03E0:  MOVFF  127,12E
03E4:  MOVLB  0
03E6:  RCALL  0200
....................    glcd_writeByte(chip, (y/8 & 0b10111111) | 0b10111000);   // Set the vertical page address 
03E8:  MOVLB  1
03EA:  RRCF   x28,W
03EC:  MOVWF  00
03EE:  RRCF   00,F
03F0:  RRCF   00,F
03F2:  MOVLW  1F
03F4:  ANDWF  00,F
03F6:  MOVF   00,W
03F8:  ANDLW  BF
03FA:  IORLW  B8
03FC:  MOVWF  x2C
03FE:  MOVFF  12B,12D
0402:  MOVWF  x2E
0404:  MOVLB  0
0406:  RCALL  0200
....................    output_high(GLCD_DI);                                    // Set for data 
0408:  BCF    F93.2
040A:  BSF    F8A.2
....................    data = glcd_readByte(chip); 
040C:  MOVFF  12B,12C
0410:  BRA    037A
0412:  MOVFF  01,12A
....................  
....................    if(color == ON) 
0416:  MOVLB  1
0418:  DECFSZ x29,W
041A:  BRA    043A
....................       bit_set(data, y%8);        // Turn the pixel on 
041C:  MOVF   x28,W
041E:  ANDLW  07
0420:  MOVWF  x2C
0422:  MOVLW  01
0424:  MOVWF  00
0426:  MOVF   x2C,W
0428:  MOVWF  01
042A:  BZ    0434
042C:  BCF    FD8.0
042E:  RLCF   00,F
0430:  DECFSZ 01,F
0432:  BRA    042C
0434:  MOVF   00,W
0436:  IORWF  x2A,F
0438:  BRA    0458
....................    else                          // or 
....................       bit_clear(data, y%8);      // turn the pixel off 
043A:  MOVF   x28,W
043C:  ANDLW  07
043E:  MOVWF  x2C
0440:  MOVLW  01
0442:  MOVWF  00
0444:  MOVF   x2C,W
0446:  MOVWF  01
0448:  BZ    0452
044A:  BCF    FD8.0
044C:  RLCF   00,F
044E:  DECFSZ 01,F
0450:  BRA    044A
0452:  MOVF   00,W
0454:  XORLW  FF
0456:  ANDWF  x2A,F
....................    output_low(GLCD_DI);          // Set for instruction 
0458:  BCF    F93.2
045A:  BCF    F8A.2
....................    glcd_writeByte(chip, x);      // Set the horizontal address 
045C:  MOVFF  12B,12D
0460:  MOVFF  127,12E
0464:  MOVLB  0
0466:  RCALL  0200
....................    output_high(GLCD_DI);         // Set for data 
0468:  BCF    F93.2
046A:  BSF    F8A.2
....................    glcd_writeByte(chip, data);   // Write the pixel data 
046C:  MOVFF  12B,12D
0470:  MOVFF  12A,12E
0474:  RCALL  0200
0476:  RETURN 0
.................... } 
....................  
....................  
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... void glcd_line(int x1, int y1, int x2, int y2, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, dx, dy; 
....................    signed long P; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
....................    x = x1; 
....................    y = y1; 
....................  
....................    if(x1 > x2) 
....................       addx = -1; 
....................    else 
....................       addx = 1; 
....................    if(y1 > y2) 
....................       addy = -1; 
....................    else 
....................       addy = 1; 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          glcd_pixel(x, y, color); 
....................  
....................          if(P < 0) 
....................          { 
....................             P += 2*dy; 
....................             x += addx; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          glcd_pixel(x, y, color); 
....................  
....................          if(P < 0) 
....................          { 
....................             P += 2*dx; 
....................             y += addy; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... void glcd_rect(int x1, int y1, int x2, int y2, int fill, int1 color) 
.................... { 
....................    if(fill) 
....................    { 
....................       int y, ymax;                          // Find the y min and max 
....................       if(y1 < y2) 
....................       { 
....................          y = y1; 
....................          ymax = y2; 
....................       } 
....................       else 
....................       { 
....................          y = y2; 
....................          ymax = y1; 
....................       } 
....................  
....................       for(; y<=ymax; ++y)                    // Draw lines to fill the rectangle 
....................          glcd_line(x1, y, x2, y, color); 
....................    } 
....................    else 
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
....................       glcd_line(x1, y2, x2, y2, color); 
....................       glcd_line(x1, y1, x1, y2, color); 
....................       glcd_line(x2, y1, x2, y2, color); 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... void glcd_bar(int x1, int y1, int x2, int y2, int width, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, j; 
....................    signed long P, dx, dy, c1, c2; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
....................    x = x1; 
....................    y = y1; 
....................    c1 = -dx*x1 - dy*y1; 
....................    c2 = -dx*x2 - dy*y2; 
....................  
....................    if(x1 > x2) 
....................    { 
....................       addx = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addx = 1; 
....................    if(y1 > y2) 
....................    { 
....................       addy = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addy = 1; 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x, y+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P += 2*dy; 
....................             x += addx; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P += 2*dx; 
....................             y += addy; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x+j, y, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... void glcd_circle(int x, int y, int radius, int1 fill, int1 color) 
.................... { 
....................    signed int a, b, P; 
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................  
....................    do 
....................    { 
....................       if(fill) 
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else 
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
....................          glcd_pixel(b+x, a+y, color); 
....................          glcd_pixel(x-a, b+y, color); 
....................          glcd_pixel(x-b, a+y, color); 
....................          glcd_pixel(b+x, y-a, color); 
....................          glcd_pixel(a+x, y-b, color); 
....................          glcd_pixel(x-a, y-b, color); 
....................          glcd_pixel(x-b, y-a, color); 
....................       } 
....................  
....................       if(P < 0) 
....................          P+= 3 + 2*a++; 
....................       else 
....................          P+= 5 + 2*(a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... void glcd_text57(int x, int y, char* textptr, int size, int1 color) 
.................... { 
....................    int i, j, k, l, m;                     // Loop counters 
....................    BYTE pixelData[5];                     // Stores character data 
....................  
....................    for(i=0; textptr[i] != '\0'; ++i, ++x) // Loop through the passed string 
0478:  MOVLB  1
047A:  CLRF   x1B
047C:  CLRF   03
047E:  MOVF   x1B,W
0480:  ADDWF  x17,W
0482:  MOVWF  FE9
0484:  MOVF   x18,W
0486:  ADDWFC 03,W
0488:  MOVWF  FEA
048A:  MOVF   FEF,F
048C:  BTFSC  FD8.2
048E:  BRA    05FE
....................    { 
....................       if(textptr[i] < 'S') // Checks if the letter is in the first text array 
0490:  CLRF   03
0492:  MOVF   x1B,W
0494:  ADDWF  x17,W
0496:  MOVWF  FE9
0498:  MOVF   x18,W
049A:  ADDWFC 03,W
049C:  MOVWF  FEA
049E:  MOVF   FEF,W
04A0:  SUBLW  52
04A2:  BNC   04F2
....................          memcpy(pixelData, TEXT[textptr[i]-' '], 5); 
04A4:  CLRF   03
04A6:  MOVF   x1B,W
04A8:  ADDWF  x17,W
04AA:  MOVWF  FE9
04AC:  MOVF   x18,W
04AE:  ADDWFC 03,W
04B0:  MOVWF  FEA
04B2:  MOVLW  20
04B4:  SUBWF  FEF,W
04B6:  MULLW  05
04B8:  MOVF   FF3,W
04BA:  CLRF   03
04BC:  MOVWF  x25
04BE:  MOVLW  01
04C0:  MOVWF  FEA
04C2:  MOVLW  20
04C4:  MOVWF  FE9
04C6:  CLRF   x29
04C8:  MOVFF  125,128
04CC:  MOVFF  FF2,126
04D0:  BCF    FF2.7
04D2:  MOVLW  05
04D4:  MOVWF  01
04D6:  CLRF   FF7
04D8:  MOVF   x25,W
04DA:  MOVLB  0
04DC:  RCALL  0004
04DE:  TBLRD*-
04E0:  TBLRD*+
04E2:  MOVFF  FF5,FEE
04E6:  DECFSZ 01,F
04E8:  BRA    04E0
04EA:  MOVLB  1
04EC:  BTFSC  x26.7
04EE:  BSF    FF2.7
04F0:  BRA    055E
....................       else if(textptr[i] <= '~') // Check if the letter is in the second array 
04F2:  CLRF   03
04F4:  MOVF   x1B,W
04F6:  ADDWF  x17,W
04F8:  MOVWF  FE9
04FA:  MOVF   x18,W
04FC:  ADDWFC 03,W
04FE:  MOVWF  FEA
0500:  MOVF   FEF,W
0502:  SUBLW  7E
0504:  BNC   0554
....................          memcpy(pixelData, TEXT2[textptr[i]-'S'], 5); 
0506:  CLRF   03
0508:  MOVF   x1B,W
050A:  ADDWF  x17,W
050C:  MOVWF  FE9
050E:  MOVF   x18,W
0510:  ADDWFC 03,W
0512:  MOVWF  FEA
0514:  MOVLW  53
0516:  SUBWF  FEF,W
0518:  MULLW  05
051A:  MOVF   FF3,W
051C:  CLRF   03
051E:  MOVWF  x25
0520:  MOVLW  01
0522:  MOVWF  FEA
0524:  MOVLW  20
0526:  MOVWF  FE9
0528:  CLRF   x29
052A:  MOVFF  125,128
052E:  MOVFF  FF2,126
0532:  BCF    FF2.7
0534:  MOVLW  05
0536:  MOVWF  01
0538:  CLRF   FF7
053A:  MOVF   x25,W
053C:  MOVLB  0
053E:  RCALL  0114
0540:  TBLRD*-
0542:  TBLRD*+
0544:  MOVFF  FF5,FEE
0548:  DECFSZ 01,F
054A:  BRA    0542
054C:  MOVLB  1
054E:  BTFSC  x26.7
0550:  BSF    FF2.7
0552:  BRA    055E
....................       else 
....................          memcpy(pixelData, TEXT[0], 5);   // Default to space 
0554:  CLRF   x20
0556:  CLRF   x21
0558:  CLRF   x22
055A:  CLRF   x23
055C:  CLRF   x24
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
055E:  MOVF   x19,W
0560:  MULLW  05
0562:  MOVF   FF3,W
0564:  ADDWF  x15,W
0566:  SUBLW  7F
0568:  BC    0576
....................       { 
....................          x = 0;                           // Set x at far left position 
056A:  CLRF   x15
....................          y += 7*size + 1;                 // Set y at next position down 
056C:  MOVF   x19,W
056E:  MULLW  07
0570:  MOVF   FF3,W
0572:  ADDLW  01
0574:  ADDWF  x16,F
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
0576:  CLRF   x1C
0578:  MOVF   x1C,W
057A:  SUBLW  04
057C:  BNC   05F8
....................       { 
....................          for(k=0; k<7*size; ++k)          // Loop through the vertical pixels 
057E:  CLRF   x1D
0580:  MOVF   x19,W
0582:  MULLW  07
0584:  MOVF   FF3,W
0586:  SUBWF  x1D,W
0588:  BC    05F0
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
058A:  CLRF   03
058C:  MOVF   x1C,W
058E:  ADDLW  20
0590:  MOVWF  FE9
0592:  MOVLW  01
0594:  ADDWFC 03,W
0596:  MOVWF  FEA
0598:  MOVFF  FEF,125
059C:  MOVFF  125,00
05A0:  MOVF   x1D,W
05A2:  MOVWF  01
05A4:  BZ    05AE
05A6:  BCF    FD8.0
05A8:  RRCF   00,F
05AA:  DECFSZ 01,F
05AC:  BRA    05A6
05AE:  BTFSS  00.0
05B0:  BRA    05EC
....................             { 
....................                for(l=0; l<size; ++l)      // The next two loops change the 
05B2:  CLRF   x1E
05B4:  MOVF   x19,W
05B6:  SUBWF  x1E,W
05B8:  BC    05EC
....................                {                          // character's size 
....................                   for(m=0; m<size; ++m) 
05BA:  CLRF   x1F
05BC:  MOVF   x19,W
05BE:  SUBWF  x1F,W
05C0:  BC    05E8
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
05C2:  MOVF   x1F,W
05C4:  ADDWF  x15,W
05C6:  MOVWF  x25
05C8:  MOVF   x1D,W
05CA:  MULWF  x19
05CC:  MOVF   FF3,W
05CE:  ADDWF  x16,W
05D0:  ADDWF  x1E,W
05D2:  MOVWF  x26
05D4:  MOVFF  125,127
05D8:  MOVWF  x28
05DA:  MOVFF  11A,129
05DE:  MOVLB  0
05E0:  RCALL  03C0
05E2:  MOVLB  1
05E4:  INCF   x1F,F
05E6:  BRA    05BC
....................                   } 
05E8:  INCF   x1E,F
05EA:  BRA    05B4
....................                } 
....................             } 
05EC:  INCF   x1D,F
05EE:  BRA    0580
....................          } 
05F0:  INCF   x1C,F
05F2:  MOVF   x19,W
05F4:  ADDWF  x15,F
05F6:  BRA    0578
....................       } 
05F8:  INCF   x1B,F
05FA:  INCF   x15,F
05FC:  BRA    047C
....................    } 
05FE:  MOVLB  0
0600:  GOTO   06E8 (RETURN)
.................... } 
....................  
....................  
.................... // Purpose:       Fill the LCD screen with the passed in color. 
.................... //                Works much faster than drawing a rectangle to fill the screen. 
.................... // Inputs:        ON - turn all the pixels on 
.................... //                OFF - turn all the pixels off 
.................... // Dependencies:  glcd_writeByte() 
.................... void glcd_fillScreen(int1 color) 
.................... { 
....................    int i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
*
0232:  MOVLB  1
0234:  CLRF   x14
0236:  MOVF   x14,W
0238:  SUBLW  07
023A:  BNC   02C4
....................    { 
....................       output_low(GLCD_DI);                      // Set for instruction 
023C:  BCF    F93.2
023E:  BCF    F8A.2
....................       glcd_writeByte(GLCD_CS1, 0b01000000);     // Set horizontal address to 0 
0240:  MOVLW  08
0242:  MOVWF  x2D
0244:  MOVLW  40
0246:  MOVWF  x2E
0248:  MOVLB  0
024A:  RCALL  0200
....................       glcd_writeByte(GLCD_CS2, 0b01000000); 
024C:  MOVLW  09
024E:  MOVLB  1
0250:  MOVWF  x2D
0252:  MOVLW  40
0254:  MOVWF  x2E
0256:  MOVLB  0
0258:  RCALL  0200
....................       glcd_writeByte(GLCD_CS1, i | 0b10111000); // Set page address 
025A:  MOVLB  1
025C:  MOVF   x14,W
025E:  IORLW  B8
0260:  MOVWF  x16
0262:  MOVLW  08
0264:  MOVWF  x2D
0266:  MOVFF  116,12E
026A:  MOVLB  0
026C:  RCALL  0200
....................       glcd_writeByte(GLCD_CS2, i | 0b10111000); 
026E:  MOVLB  1
0270:  MOVF   x14,W
0272:  IORLW  B8
0274:  MOVWF  x16
0276:  MOVLW  09
0278:  MOVWF  x2D
027A:  MOVFF  116,12E
027E:  MOVLB  0
0280:  RCALL  0200
....................       output_high(GLCD_DI);                     // Set for data 
0282:  BCF    F93.2
0284:  BSF    F8A.2
....................  
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
0286:  MOVLB  1
0288:  CLRF   x15
028A:  MOVF   x15,W
028C:  SUBLW  3F
028E:  BNC   02C0
....................       { 
....................          glcd_writeByte(GLCD_CS1, 0xFF*color);  // Turn pixels on or off 
0290:  MOVF   x13,W
0292:  MULLW  FF
0294:  MOVFF  FF3,116
0298:  MOVLW  08
029A:  MOVWF  x2D
029C:  MOVFF  116,12E
02A0:  MOVLB  0
02A2:  RCALL  0200
....................          glcd_writeByte(GLCD_CS2, 0xFF*color);  // Turn pixels on or off 
02A4:  MOVLB  1
02A6:  MOVF   x13,W
02A8:  MULLW  FF
02AA:  MOVFF  FF3,116
02AE:  MOVLW  09
02B0:  MOVWF  x2D
02B2:  MOVFF  116,12E
02B6:  MOVLB  0
02B8:  RCALL  0200
02BA:  MOVLB  1
02BC:  INCF   x15,F
02BE:  BRA    028A
....................       } 
02C0:  INCF   x14,F
02C2:  BRA    0236
....................    } 
02C4:  MOVLB  0
02C6:  RETURN 0
.................... } 
....................  
.................... // Purpose:       Write a byte of data to the specified chip 
.................... // Inputs:        chipSelect - which chip to write the data to 
.................... //                data - the byte of data to write 
....................  
.................... void glcd_writeByte(char chip, BYTE data) 
.................... { 
....................    if(chip == GLCD_CS1)       // Choose which chip to write to 
*
0200:  MOVLB  1
0202:  MOVF   x2D,W
0204:  SUBLW  08
0206:  BNZ   020E
....................       output_high(GLCD_CS1); 
0208:  BCF    F93.0
020A:  BSF    F8A.0
020C:  BRA    0212
....................    else 
....................       output_high(GLCD_CS2); 
020E:  BCF    F93.1
0210:  BSF    F8A.1
....................  
....................    output_low(GLCD_RW);       // Set for writing 
0212:  BCF    F93.4
0214:  BCF    F8A.4
....................    output_d(data);            // Put the data on the port 
0216:  CLRF   F95
0218:  MOVFF  12E,F8C
....................    output_high(GLCD_E);       // Pulse the enable pin 
021C:  BCF    F93.5
021E:  BSF    F8A.5
....................    delay_us(2); 
0220:  BRA    0222
....................    output_low(GLCD_E); 
0222:  BCF    F93.5
0224:  BCF    F8A.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
0226:  BCF    F93.0
0228:  BCF    F8A.0
....................    output_low(GLCD_CS2); 
022A:  BCF    F93.1
022C:  BCF    F8A.1
022E:  MOVLB  0
0230:  RETURN 0
.................... } 
....................  
....................  
.................... // Purpose:       Reads a byte of data from the specified chip 
.................... // Ouputs:        A byte of data read from the chip 
.................... BYTE glcd_readByte(BYTE chip) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................    if(chip == GLCD_CS1)       // Choose which chip to read from 
*
037A:  MOVLB  1
037C:  MOVF   x2C,W
037E:  SUBLW  08
0380:  BNZ   0388
....................       output_high(GLCD_CS1); 
0382:  BCF    F93.0
0384:  BSF    F8A.0
0386:  BRA    038C
....................    else 
....................       output_high(GLCD_CS2); 
0388:  BCF    F93.1
038A:  BSF    F8A.1
....................  
....................    input_d();                 // Set port d to input 
038C:  SETF   F95
....................    output_high(GLCD_RW);      // Set for reading 
038E:  BCF    F93.4
0390:  BSF    F8A.4
....................    output_high(GLCD_E);       // Pulse the enable pin 
0392:  BCF    F93.5
0394:  BSF    F8A.5
....................    delay_us(2); 
0396:  BRA    0398
....................    output_low(GLCD_E); 
0398:  BCF    F93.5
039A:  BCF    F8A.5
....................    delay_us(2); 
039C:  BRA    039E
....................    output_high(GLCD_E);       // Pulse the enable pin 
039E:  BCF    F93.5
03A0:  BSF    F8A.5
....................    delay_us(2); 
03A2:  BRA    03A4
....................    data = input_d();          // Get the data from the display's output register 
03A4:  SETF   F95
03A6:  MOVFF  F83,12D
....................    output_low(GLCD_E); 
03AA:  BCF    F93.5
03AC:  BCF    F8A.5
....................  
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
03AE:  BCF    F93.0
03B0:  BCF    F8A.0
....................    output_low(GLCD_CS2); 
03B2:  BCF    F93.1
03B4:  BCF    F8A.1
....................    return data;               // Return the read data 
03B6:  MOVFF  12D,01
03BA:  MOVLB  0
03BC:  GOTO   0412 (RETURN)
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... #define width     128 
.................... #define height    64 
.................... #define initSize  10 
.................... #define direita   0 
.................... #define dir       pin_c1 
.................... #define cima      1 
.................... #define cim       pin_c2 
.................... #define esquerda  2 
.................... #define esq       pin_c4 
.................... #define baixo     3 
.................... #define bai       pin_c5 
.................... char yl[10] = "You Lose!"; 
.................... struct Dot{ 
....................    unsigned int x; 
....................    unsigned int y; 
.................... }; 
.................... struct Dot snake[128]; 
.................... struct Dot point; 
.................... int8   sentido; 
.................... int8   size=initSize; 
....................  
.................... void mov(){ 
....................    int8 i; 
....................    struct Dot aux; 
....................    aux.x = snake[0].x; 
*
062E:  MOVFF  0E,113
....................    aux.y = snake[0].y; 
0632:  MOVFF  0F,114
....................    switch (sentido){ 
0636:  MOVLB  1
0638:  MOVF   x10,W
063A:  ADDLW  FC
063C:  BC    0688
063E:  ADDLW  04
0640:  MOVLB  0
0642:  GOTO   085E
....................       case direita: 
....................          if(aux.x==width-1) 
0646:  MOVLB  1
0648:  MOVF   x13,W
064A:  SUBLW  7F
064C:  BNZ   0652
....................             aux.x=0; 
064E:  CLRF   x13
0650:  BRA    0654
....................          else 
....................             aux.x++; 
0652:  INCF   x13,F
....................       break; 
0654:  BRA    0688
....................       case cima: 
....................          if(aux.y==0) 
0656:  MOVLB  1
0658:  MOVF   x14,F
065A:  BNZ   0662
....................             aux.y=height-1; 
065C:  MOVLW  3F
065E:  MOVWF  x14
0660:  BRA    0664
....................          else 
....................             aux.y--; 
0662:  DECF   x14,F
....................       break; 
0664:  BRA    0688
....................       case esquerda: 
....................          if(aux.x==0) 
0666:  MOVLB  1
0668:  MOVF   x13,F
066A:  BNZ   0672
....................             aux.x=width-1; 
066C:  MOVLW  7F
066E:  MOVWF  x13
0670:  BRA    0674
....................          else 
....................             aux.x--; 
0672:  DECF   x13,F
....................       break; 
0674:  BRA    0688
....................       case baixo: 
....................          if(aux.y==height-1) 
0676:  MOVLB  1
0678:  MOVF   x14,W
067A:  SUBLW  3F
067C:  BNZ   0682
....................             aux.y=0; 
067E:  CLRF   x14
0680:  BRA    0684
....................          else 
....................             aux.y++; 
0682:  INCF   x14,F
....................       break; 
0684:  BRA    0688
0686:  MOVLB  1
....................    } 
....................    for(i=1;i<size;i++){ 
0688:  MOVLW  01
068A:  MOVWF  x12
068C:  MOVF   x11,W
068E:  SUBWF  x12,W
0690:  BC    0702
....................       if(aux.x==snake[i].x && aux.y==snake[i].y){     //end game 
0692:  BCF    FD8.0
0694:  RLCF   x12,W
0696:  CLRF   x16
0698:  MOVWF  x15
069A:  MOVLW  0E
069C:  ADDWF  x15,W
069E:  MOVWF  FE9
06A0:  MOVLW  00
06A2:  ADDWFC x16,W
06A4:  MOVWF  FEA
06A6:  MOVF   FEF,W
06A8:  SUBWF  x13,W
06AA:  BNZ   06FE
06AC:  BCF    FD8.0
06AE:  RLCF   x12,W
06B0:  CLRF   x18
06B2:  MOVWF  x17
06B4:  MOVLW  01
06B6:  ADDWF  x17,W
06B8:  MOVWF  01
06BA:  MOVLW  00
06BC:  ADDWFC x18,W
06BE:  MOVWF  03
06C0:  MOVF   01,W
06C2:  ADDLW  0E
06C4:  MOVWF  FE9
06C6:  MOVLW  00
06C8:  ADDWFC 03,W
06CA:  MOVWF  FEA
06CC:  MOVF   FEF,W
06CE:  SUBWF  x14,W
06D0:  BNZ   06FE
....................          glcd_text57(0,0,yl,2,1); 
06D2:  CLRF   x15
06D4:  CLRF   x16
06D6:  CLRF   x18
06D8:  MOVLW  04
06DA:  MOVWF  x17
06DC:  MOVLW  02
06DE:  MOVWF  x19
06E0:  MOVLW  01
06E2:  MOVWF  x1A
06E4:  MOVLB  0
06E6:  BRA    0478
....................          delay_ms(1000); 
06E8:  MOVLW  04
06EA:  MOVLB  1
06EC:  MOVWF  x15
06EE:  MOVLW  FA
06F0:  MOVWF  x16
06F2:  MOVLB  0
06F4:  RCALL  0604
06F6:  MOVLB  1
06F8:  DECFSZ x15,F
06FA:  BRA    06EE
....................          return; 
06FC:  BRA    0858
....................       } 
06FE:  INCF   x12,F
0700:  BRA    068C
....................    } 
....................    if(aux.x==point.x && aux.y==point.y){ 
0702:  MOVF   x0E,W
0704:  SUBWF  x13,W
0706:  BNZ   0738
0708:  MOVF   x0F,W
070A:  SUBWF  x14,W
070C:  BNZ   0738
....................       size++; 
070E:  INCF   x11,F
....................       point.x = get_timer0() % width; 
0710:  MOVF   FD6,W
0712:  MOVWF  x15
0714:  MOVF   x15,W
0716:  ANDLW  7F
0718:  MOVWF  x0E
....................       point.y = get_timer0() % height; 
071A:  MOVF   FD6,W
071C:  MOVWF  x15
071E:  MOVF   x15,W
0720:  ANDLW  3F
0722:  MOVWF  x0F
....................       glcd_pixel(point.x,point.y,1); 
0724:  MOVFF  10E,127
0728:  MOVFF  10F,128
072C:  MOVLW  01
072E:  MOVWF  x29
0730:  MOVLB  0
0732:  RCALL  03C0
....................    } 
0734:  BRA    0792
0736:  MOVLB  1
....................    else{ 
....................       glcd_pixel(snake[size-1].x,snake[size-1].y,0); 
0738:  MOVLW  01
073A:  SUBWF  x11,W
073C:  MOVWF  00
073E:  BCF    FD8.0
0740:  RLCF   00,F
0742:  MOVF   00,W
0744:  CLRF   x16
0746:  MOVWF  x15
0748:  MOVLW  0E
074A:  ADDWF  x15,W
074C:  MOVWF  FE9
074E:  MOVLW  00
0750:  ADDWFC x16,W
0752:  MOVWF  FEA
0754:  MOVFF  FEF,117
0758:  MOVLW  01
075A:  SUBWF  x11,W
075C:  MOVWF  00
075E:  BCF    FD8.0
0760:  RLCF   00,F
0762:  MOVF   00,W
0764:  CLRF   x19
0766:  MOVWF  x18
0768:  MOVLW  01
076A:  ADDWF  x18,W
076C:  MOVWF  01
076E:  MOVLW  00
0770:  ADDWFC x19,W
0772:  MOVWF  03
0774:  MOVF   01,W
0776:  ADDLW  0E
0778:  MOVWF  FE9
077A:  MOVLW  00
077C:  ADDWFC 03,W
077E:  MOVWF  FEA
0780:  MOVFF  FEF,118
0784:  MOVFF  117,127
0788:  MOVFF  118,128
078C:  CLRF   x29
078E:  MOVLB  0
0790:  RCALL  03C0
....................    } 
....................    glcd_pixel(aux.x,aux.y,1); 
0792:  MOVFF  113,127
0796:  MOVFF  114,128
079A:  MOVLW  01
079C:  MOVLB  1
079E:  MOVWF  x29
07A0:  MOVLB  0
07A2:  RCALL  03C0
....................    for(i=size;i>0;i--){ 
07A4:  MOVFF  111,112
07A8:  MOVLB  1
07AA:  MOVF   x12,F
07AC:  BZ    0850
....................       snake[i].x=snake[i-1].x; 
07AE:  BCF    FD8.0
07B0:  RLCF   x12,W
07B2:  CLRF   x16
07B4:  MOVWF  x15
07B6:  MOVLW  0E
07B8:  ADDWF  x15,W
07BA:  MOVWF  01
07BC:  MOVLW  00
07BE:  ADDWFC x16,W
07C0:  MOVWF  03
07C2:  MOVLW  01
07C4:  SUBWF  x12,W
07C6:  MOVWF  00
07C8:  BCF    FD8.0
07CA:  RLCF   00,F
07CC:  MOVF   00,W
07CE:  CLRF   x1A
07D0:  MOVWF  x19
07D2:  MOVLW  0E
07D4:  ADDWF  x19,W
07D6:  MOVWF  FE9
07D8:  MOVLW  00
07DA:  ADDWFC x1A,W
07DC:  MOVWF  FEA
07DE:  MOVFF  FEF,11B
07E2:  MOVFF  03,FEA
07E6:  MOVFF  01,FE9
07EA:  MOVFF  11B,FEF
....................       snake[i].y=snake[i-1].y; 
07EE:  BCF    FD8.0
07F0:  RLCF   x12,W
07F2:  CLRF   x16
07F4:  MOVWF  x15
07F6:  MOVLW  01
07F8:  ADDWF  x15,W
07FA:  MOVWF  01
07FC:  MOVLW  00
07FE:  ADDWFC x16,W
0800:  MOVWF  03
0802:  MOVF   01,W
0804:  ADDLW  0E
0806:  MOVWF  01
0808:  MOVLW  00
080A:  ADDWFC 03,F
080C:  MOVFF  01,115
0810:  MOVFF  03,116
0814:  MOVLW  01
0816:  SUBWF  x12,W
0818:  MOVWF  00
081A:  BCF    FD8.0
081C:  RLCF   00,F
081E:  MOVF   00,W
0820:  CLRF   x18
0822:  MOVWF  x17
0824:  MOVLW  01
0826:  ADDWF  x17,W
0828:  MOVWF  01
082A:  MOVLW  00
082C:  ADDWFC x18,W
082E:  MOVWF  03
0830:  MOVF   01,W
0832:  ADDLW  0E
0834:  MOVWF  FE9
0836:  MOVLW  00
0838:  ADDWFC 03,W
083A:  MOVWF  FEA
083C:  MOVFF  FEF,117
0840:  MOVFF  116,FEA
0844:  MOVFF  115,FE9
0848:  MOVFF  117,FEF
084C:  DECF   x12,F
084E:  BRA    07AA
....................    } 
....................    snake[0].x=aux.x; 
0850:  MOVFF  113,0E
....................    snake[0].y=aux.y; 
0854:  MOVFF  114,0F
0858:  MOVLB  0
085A:  GOTO   0986 (RETURN)
.................... } 
....................  
.................... /*void draw(){ 
....................    int8 i; 
....................    glcd_fillScreen(0); 
....................    for(i=1;i<size;i++){ 
....................       glcd_pixel(snake[i].x,snake[i].y,1); 
....................    } 
....................    glcd_pixel(point.x,point.y,1); 
.................... }*/ 
....................  
.................... void main(){ 
*
0880:  CLRF   FF8
0882:  BCF    FD0.7
0884:  MOVLW  0A
0886:  MOVLB  1
0888:  MOVWF  x11
088A:  MOVF   FC1,W
088C:  ANDLW  C0
088E:  IORLW  0F
0890:  MOVWF  FC1
0892:  MOVLW  07
0894:  MOVWF  FB4
0896:  MOVLW  59
0898:  MOVWF  04
089A:  MOVLW  6F
089C:  MOVWF  05
089E:  MOVLW  75
08A0:  MOVWF  06
08A2:  MOVLW  20
08A4:  MOVWF  07
08A6:  MOVLW  4C
08A8:  MOVWF  08
08AA:  MOVLW  6F
08AC:  MOVWF  09
08AE:  MOVLW  73
08B0:  MOVWF  0A
08B2:  MOVLW  65
08B4:  MOVWF  0B
08B6:  MOVLW  21
08B8:  MOVWF  0C
08BA:  CLRF   0D
....................    setup_adc_ports(AN0); 
08BC:  MOVF   FC1,W
08BE:  ANDLW  C0
08C0:  IORLW  0E
08C2:  MOVWF  FC1
....................    setup_adc(ADC_CLOCK_INTERNAL|ADC_TAD_MUL_0); 
08C4:  MOVF   FC0,W
08C6:  ANDLW  C0
08C8:  IORLW  07
08CA:  MOVWF  FC0
08CC:  BCF    FC0.7
08CE:  BSF    FC2.0
....................    setup_psp(PSP_DISABLED); 
08D0:  BCF    F96.4
....................    setup_spi(SPI_SS_DISABLED); 
08D2:  BCF    FC6.5
08D4:  BCF    F94.7
08D6:  BSF    F93.0
08D8:  BCF    F93.1
08DA:  MOVLW  01
08DC:  MOVWF  FC6
08DE:  MOVLW  00
08E0:  MOVWF  FC7
....................    setup_wdt(WDT_OFF); 
08E2:  BCF    FD1.0
....................    setup_timer_0(RTCC_INTERNAL); 
08E4:  MOVLW  80
08E6:  MOVWF  FD5
....................    setup_timer_1(T1_DISABLED); 
08E8:  CLRF   FCD
....................    setup_timer_2(T2_DISABLED,0,1); 
08EA:  MOVLW  00
08EC:  MOVWF  FCA
08EE:  MOVLW  00
08F0:  MOVWF  FCB
....................    setup_timer_3(T3_DISABLED|T3_DIV_BY_1); 
08F2:  CLRF   FB1
....................  
....................    glcd_init(ON);   //inicializa o display 
08F4:  MOVLW  01
08F6:  MOVWF  x12
08F8:  MOVLB  0
08FA:  BRA    02C8
....................    glcd_fillScreen(0); //limpa display inteiro 
08FC:  MOVLB  1
08FE:  CLRF   x13
0900:  MOVLB  0
0902:  RCALL  0232
....................  
....................    snake[0].x = 10; 
0904:  MOVLW  0A
0906:  MOVWF  0E
....................    snake[0].y = 32; 
0908:  MOVLW  20
090A:  MOVWF  0F
....................    /*snake[1].x = 63; 
....................    snake[1].y = 32; 
....................    snake[2].x = 62; 
....................    snake[2].y = 32; 
....................    snake[3].x = 61; 
....................    snake[3].y = 32;*/ 
....................     
....................    point.x = get_timer0() % width; 
090C:  MOVF   FD6,W
090E:  MOVLB  1
0910:  MOVWF  x12
0912:  MOVF   x12,W
0914:  ANDLW  7F
0916:  MOVWF  x0E
....................    point.y = get_timer0() % height; 
0918:  MOVF   FD6,W
091A:  MOVWF  x12
091C:  MOVF   x12,W
091E:  ANDLW  3F
0920:  MOVWF  x0F
....................    glcd_pixel(point.x,point.y,1); 
0922:  MOVFF  10E,127
0926:  MOVFF  10F,128
092A:  MOVLW  01
092C:  MOVWF  x29
092E:  MOVLB  0
0930:  RCALL  03C0
....................     
....................    while(TRUE){ 
....................       if(input(dir)){ 
0932:  BSF    F94.1
0934:  BTFSS  F82.1
0936:  BRA    0946
....................          if(sentido!=esquerda) 
0938:  MOVLB  1
093A:  MOVF   x10,W
093C:  SUBLW  02
093E:  BZ    0942
....................             sentido = direita; 
0940:  CLRF   x10
....................       } 
0942:  BRA    0982
0944:  MOVLB  0
....................       else if(input(cim)){ 
0946:  BSF    F94.2
0948:  BTFSS  F82.2
094A:  BRA    095C
....................          if(sentido!=baixo) 
094C:  MOVLB  1
094E:  MOVF   x10,W
0950:  SUBLW  03
0952:  BZ    0958
....................             sentido = cima; 
0954:  MOVLW  01
0956:  MOVWF  x10
....................       } 
0958:  BRA    0982
095A:  MOVLB  0
....................       else if(input(esq)){ 
095C:  BSF    F94.4
095E:  BTFSS  F82.4
0960:  BRA    0970
....................          if(sentido!=direita) 
0962:  MOVLB  1
0964:  MOVF   x10,F
0966:  BZ    096C
....................             sentido = esquerda; 
0968:  MOVLW  02
096A:  MOVWF  x10
....................       } 
096C:  BRA    0982
096E:  MOVLB  0
....................       else if(input(bai)){ 
0970:  BSF    F94.5
0972:  BTFSS  F82.5
0974:  BRA    0984
....................          if(sentido!=cima) 
0976:  MOVLB  1
0978:  DECFSZ x10,W
097A:  BRA    097E
097C:  BRA    0982
....................             sentido = baixo; 
097E:  MOVLW  03
0980:  MOVWF  x10
0982:  MOVLB  0
....................       } 
....................       mov(); 
0984:  BRA    062E
....................       delay_ms(100); 
0986:  MOVLW  64
0988:  MOVLB  1
098A:  MOVWF  x16
098C:  MOVLB  0
098E:  RCALL  0604
0990:  BRA    0932
....................    } 
.................... } 
0992:  SLEEP 

Configuration Fuses:
   Word  1: C000   PLL1 CPUDIV1 NOUSBDIV XT FCMEN IESO
   Word  2: 0E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT128
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
